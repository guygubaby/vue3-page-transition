{"resolvedId":"/Users/bryce/i/vue3-page-transition/playground/node_modules/.vite/deps/chunk-34TZLNIG.js?v=7d84460d","transforms":[{"name":"vite:optimized-deps","result":"import {\n  defineComponent,\n  inject,\n  onBeforeUnmount,\n  ref,\n  shallowRef,\n  unref,\n  watchEffect\n} from \"./chunk-IGCPF6BW.js\";\n\n// ../node_modules/.pnpm/@vueuse+head@0.7.10_vue@3.2.39/node_modules/@vueuse/head/dist/index.mjs\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar PROVIDE_KEY = `usehead`;\nvar HEAD_COUNT_KEY = `head:count`;\nvar HEAD_ATTRS_KEY = `data-head-attrs`;\nvar SELF_CLOSING_TAGS = [\"meta\", \"link\", \"base\"];\nvar BODY_TAG_ATTR_NAME = `data-meta-body`;\nvar createElement = (tag, attrs, document) => {\n  const el = document.createElement(tag);\n  for (const key of Object.keys(attrs)) {\n    if (key === \"body\" && attrs.body === true) {\n      el.setAttribute(BODY_TAG_ATTR_NAME, \"true\");\n    } else {\n      let value = attrs[key];\n      if (key === \"key\" || value === false) {\n        continue;\n      }\n      if (key === \"children\") {\n        el.textContent = value;\n      } else {\n        el.setAttribute(key, value);\n      }\n    }\n  }\n  return el;\n};\nvar htmlEscape = (str) => str.replace(/&/g, \"&amp;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#39;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\nvar stringifyAttrs = (attributes) => {\n  const handledAttributes = [];\n  for (let [key, value] of Object.entries(attributes)) {\n    if (key === \"children\" || key === \"key\") {\n      continue;\n    }\n    if (value === false || value == null) {\n      continue;\n    }\n    let attribute = htmlEscape(key);\n    if (value !== true) {\n      attribute += `=\"${htmlEscape(String(value))}\"`;\n    }\n    handledAttributes.push(attribute);\n  }\n  return handledAttributes.length > 0 ? \" \" + handledAttributes.join(\" \") : \"\";\n};\nfunction isEqualNode(oldTag, newTag) {\n  if (oldTag instanceof HTMLElement && newTag instanceof HTMLElement) {\n    const nonce = newTag.getAttribute(\"nonce\");\n    if (nonce && !oldTag.getAttribute(\"nonce\")) {\n      const cloneTag = newTag.cloneNode(true);\n      cloneTag.setAttribute(\"nonce\", \"\");\n      cloneTag.nonce = nonce;\n      return nonce === oldTag.nonce && oldTag.isEqualNode(cloneTag);\n    }\n  }\n  return oldTag.isEqualNode(newTag);\n}\nvar getTagKey = (props) => {\n  const names = [\"key\", \"id\", \"name\", \"property\"];\n  for (const n of names) {\n    const value = typeof props.getAttribute === \"function\" ? props.hasAttribute(n) ? props.getAttribute(n) : void 0 : props[n];\n    if (value !== void 0) {\n      return { name: n, value };\n    }\n  }\n};\nvar injectHead = () => {\n  const head = inject(PROVIDE_KEY);\n  if (!head) {\n    throw new Error(`You may forget to apply app.use(head)`);\n  }\n  return head;\n};\nvar acceptFields = [\n  \"title\",\n  \"meta\",\n  \"link\",\n  \"base\",\n  \"style\",\n  \"script\",\n  \"noscript\",\n  \"htmlAttrs\",\n  \"bodyAttrs\"\n];\nvar renderTemplate = (template, title) => {\n  if (template == null)\n    return \"\";\n  if (typeof template === \"string\") {\n    return template.replace(\"%s\", title != null ? title : \"\");\n  }\n  return template(unref(title));\n};\nvar headObjToTags = (obj) => {\n  const tags = [];\n  const keys = Object.keys(obj);\n  for (const key of keys) {\n    if (obj[key] == null)\n      continue;\n    switch (key) {\n      case \"title\":\n        tags.push({ tag: key, props: { children: obj[key] } });\n        break;\n      case \"titleTemplate\":\n        break;\n      case \"base\":\n        tags.push({ tag: key, props: __spreadValues({ key: \"default\" }, obj[key]) });\n        break;\n      default:\n        if (acceptFields.includes(key)) {\n          const value = obj[key];\n          if (Array.isArray(value)) {\n            value.forEach((item) => {\n              tags.push({ tag: key, props: item });\n            });\n          } else if (value) {\n            tags.push({ tag: key, props: value });\n          }\n        }\n        break;\n    }\n  }\n  return tags;\n};\nvar setAttrs = (el, attrs) => {\n  const existingAttrs = el.getAttribute(HEAD_ATTRS_KEY);\n  if (existingAttrs) {\n    for (const key of existingAttrs.split(\",\")) {\n      if (!(key in attrs)) {\n        el.removeAttribute(key);\n      }\n    }\n  }\n  const keys = [];\n  for (const key in attrs) {\n    const value = attrs[key];\n    if (value == null)\n      continue;\n    if (value === false) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, value);\n    }\n    keys.push(key);\n  }\n  if (keys.length) {\n    el.setAttribute(HEAD_ATTRS_KEY, keys.join(\",\"));\n  } else {\n    el.removeAttribute(HEAD_ATTRS_KEY);\n  }\n};\nvar updateElements = (document = window.document, type, tags) => {\n  var _a, _b;\n  const head = document.head;\n  const body = document.body;\n  let headCountEl = head.querySelector(`meta[name=\"${HEAD_COUNT_KEY}\"]`);\n  let bodyMetaElements = body.querySelectorAll(`[${BODY_TAG_ATTR_NAME}]`);\n  const headCount = headCountEl ? Number(headCountEl.getAttribute(\"content\")) : 0;\n  const oldHeadElements = [];\n  const oldBodyElements = [];\n  if (bodyMetaElements) {\n    for (let i = 0; i < bodyMetaElements.length; i++) {\n      if (bodyMetaElements[i] && ((_a = bodyMetaElements[i].tagName) == null ? void 0 : _a.toLowerCase()) === type) {\n        oldBodyElements.push(bodyMetaElements[i]);\n      }\n    }\n  }\n  if (headCountEl) {\n    for (let i = 0, j = headCountEl.previousElementSibling; i < headCount; i++, j = (j == null ? void 0 : j.previousElementSibling) || null) {\n      if (((_b = j == null ? void 0 : j.tagName) == null ? void 0 : _b.toLowerCase()) === type) {\n        oldHeadElements.push(j);\n      }\n    }\n  } else {\n    headCountEl = document.createElement(\"meta\");\n    headCountEl.setAttribute(\"name\", HEAD_COUNT_KEY);\n    headCountEl.setAttribute(\"content\", \"0\");\n    head.append(headCountEl);\n  }\n  let newElements = tags.map((tag) => {\n    var _a2;\n    return {\n      element: createElement(tag.tag, tag.props, document),\n      body: (_a2 = tag.props.body) != null ? _a2 : false\n    };\n  });\n  newElements = newElements.filter((newEl) => {\n    for (let i = 0; i < oldHeadElements.length; i++) {\n      const oldEl = oldHeadElements[i];\n      if (isEqualNode(oldEl, newEl.element)) {\n        oldHeadElements.splice(i, 1);\n        return false;\n      }\n    }\n    for (let i = 0; i < oldBodyElements.length; i++) {\n      const oldEl = oldBodyElements[i];\n      if (isEqualNode(oldEl, newEl.element)) {\n        oldBodyElements.splice(i, 1);\n        return false;\n      }\n    }\n    return true;\n  });\n  oldBodyElements.forEach((t) => {\n    var _a2;\n    return (_a2 = t.parentNode) == null ? void 0 : _a2.removeChild(t);\n  });\n  oldHeadElements.forEach((t) => {\n    var _a2;\n    return (_a2 = t.parentNode) == null ? void 0 : _a2.removeChild(t);\n  });\n  newElements.forEach((t) => {\n    if (t.body === true) {\n      body.insertAdjacentElement(\"beforeend\", t.element);\n    } else {\n      head.insertBefore(t.element, headCountEl);\n    }\n  });\n  headCountEl.setAttribute(\"content\", \"\" + (headCount - oldHeadElements.length + newElements.filter((t) => !t.body).length));\n};\nvar createHead = (initHeadObject) => {\n  let allHeadObjs = [];\n  let previousTags = /* @__PURE__ */ new Set();\n  if (initHeadObject) {\n    allHeadObjs.push(shallowRef(initHeadObject));\n  }\n  const head = {\n    install(app) {\n      app.config.globalProperties.$head = head;\n      app.provide(PROVIDE_KEY, head);\n    },\n    get headTags() {\n      const deduped = [];\n      const titleTemplate = allHeadObjs.map((i) => unref(i).titleTemplate).reverse().find((i) => i != null);\n      allHeadObjs.forEach((objs) => {\n        const tags = headObjToTags(unref(objs));\n        tags.forEach((tag) => {\n          if (tag.tag === \"meta\" || tag.tag === \"base\" || tag.tag === \"script\") {\n            const key = getTagKey(tag.props);\n            if (key) {\n              let index = -1;\n              for (let i = 0; i < deduped.length; i++) {\n                const prev = deduped[i];\n                const prevValue = prev.props[key.name];\n                const nextValue = tag.props[key.name];\n                if (prev.tag === tag.tag && prevValue === nextValue) {\n                  index = i;\n                  break;\n                }\n              }\n              if (index !== -1) {\n                deduped.splice(index, 1);\n              }\n            }\n          }\n          if (titleTemplate && tag.tag === \"title\") {\n            tag.props.children = renderTemplate(titleTemplate, tag.props.children);\n          }\n          deduped.push(tag);\n        });\n      });\n      return deduped;\n    },\n    addHeadObjs(objs) {\n      allHeadObjs.push(objs);\n    },\n    removeHeadObjs(objs) {\n      allHeadObjs = allHeadObjs.filter((_objs) => _objs !== objs);\n    },\n    updateDOM(document = window.document) {\n      let title;\n      let htmlAttrs = {};\n      let bodyAttrs = {};\n      const actualTags = {};\n      for (const tag of head.headTags) {\n        if (tag.tag === \"title\") {\n          title = tag.props.children;\n          continue;\n        }\n        if (tag.tag === \"htmlAttrs\") {\n          Object.assign(htmlAttrs, tag.props);\n          continue;\n        }\n        if (tag.tag === \"bodyAttrs\") {\n          Object.assign(bodyAttrs, tag.props);\n          continue;\n        }\n        actualTags[tag.tag] = actualTags[tag.tag] || [];\n        actualTags[tag.tag].push(tag);\n      }\n      if (title !== void 0) {\n        document.title = title;\n      }\n      setAttrs(document.documentElement, htmlAttrs);\n      setAttrs(document.body, bodyAttrs);\n      const tags = /* @__PURE__ */ new Set([...Object.keys(actualTags), ...previousTags]);\n      for (const tag of tags) {\n        updateElements(document, tag, actualTags[tag] || []);\n      }\n      previousTags.clear();\n      Object.keys(actualTags).forEach((i) => previousTags.add(i));\n    }\n  };\n  return head;\n};\nvar IS_BROWSER = typeof window !== \"undefined\";\nvar useHead = (obj) => {\n  const head = injectHead();\n  const headObj = ref(obj);\n  head.addHeadObjs(headObj);\n  if (IS_BROWSER) {\n    watchEffect(() => {\n      head.updateDOM();\n    });\n    onBeforeUnmount(() => {\n      head.removeHeadObjs(headObj);\n      head.updateDOM();\n    });\n  }\n};\nvar tagToString = (tag) => {\n  let isBodyTag = false;\n  if (tag.props.body) {\n    isBodyTag = true;\n    delete tag.props.body;\n  }\n  let attrs = stringifyAttrs(tag.props);\n  if (SELF_CLOSING_TAGS.includes(tag.tag)) {\n    return `<${tag.tag}${attrs}${isBodyTag ? `  ${BODY_TAG_ATTR_NAME}=\"true\"` : \"\"}>`;\n  }\n  return `<${tag.tag}${attrs}${isBodyTag ? ` ${BODY_TAG_ATTR_NAME}=\"true\"` : \"\"}>${tag.props.children || \"\"}</${tag.tag}>`;\n};\nvar renderHeadToString = (head) => {\n  const tags = [];\n  let titleTag = \"\";\n  let htmlAttrs = {};\n  let bodyAttrs = {};\n  let bodyTags = [];\n  for (const tag of head.headTags) {\n    if (tag.tag === \"title\") {\n      titleTag = tagToString(tag);\n    } else if (tag.tag === \"htmlAttrs\") {\n      Object.assign(htmlAttrs, tag.props);\n    } else if (tag.tag === \"bodyAttrs\") {\n      Object.assign(bodyAttrs, tag.props);\n    } else if (tag.props.body) {\n      bodyTags.push(tagToString(tag));\n    } else {\n      tags.push(tagToString(tag));\n    }\n  }\n  tags.push(`<meta name=\"${HEAD_COUNT_KEY}\" content=\"${tags.length}\">`);\n  return {\n    get headTags() {\n      return titleTag + tags.join(\"\");\n    },\n    get htmlAttrs() {\n      return stringifyAttrs(__spreadProps(__spreadValues({}, htmlAttrs), {\n        [HEAD_ATTRS_KEY]: Object.keys(htmlAttrs).join(\",\")\n      }));\n    },\n    get bodyAttrs() {\n      return stringifyAttrs(__spreadProps(__spreadValues({}, bodyAttrs), {\n        [HEAD_ATTRS_KEY]: Object.keys(bodyAttrs).join(\",\")\n      }));\n    },\n    get bodyTags() {\n      return bodyTags.join(\"\");\n    }\n  };\n};\nvar addVNodeToHeadObj = (node, obj) => {\n  const type = node.type === \"html\" ? \"htmlAttrs\" : node.type === \"body\" ? \"bodyAttrs\" : node.type;\n  if (typeof type !== \"string\" || !(type in obj))\n    return;\n  const props = __spreadProps(__spreadValues({}, node.props), {\n    children: Array.isArray(node.children) ? node.children[0].children : node.children\n  });\n  if (Array.isArray(obj[type])) {\n    ;\n    obj[type].push(props);\n  } else if (type === \"title\") {\n    obj.title = props.children;\n  } else {\n    ;\n    obj[type] = props;\n  }\n};\nvar vnodesToHeadObj = (nodes) => {\n  const obj = {\n    title: void 0,\n    htmlAttrs: void 0,\n    bodyAttrs: void 0,\n    base: void 0,\n    meta: [],\n    link: [],\n    style: [],\n    script: [],\n    noscript: []\n  };\n  for (const node of nodes) {\n    if (typeof node.type === \"symbol\" && Array.isArray(node.children)) {\n      for (const childNode of node.children) {\n        addVNodeToHeadObj(childNode, obj);\n      }\n    } else {\n      addVNodeToHeadObj(node, obj);\n    }\n  }\n  return obj;\n};\nvar Head = defineComponent({\n  name: \"Head\",\n  setup(_, { slots }) {\n    const head = injectHead();\n    let obj;\n    onBeforeUnmount(() => {\n      if (obj) {\n        head.removeHeadObjs(obj);\n        head.updateDOM();\n      }\n    });\n    return () => {\n      watchEffect(() => {\n        if (!slots.default)\n          return;\n        if (obj) {\n          head.removeHeadObjs(obj);\n        }\n        obj = ref(vnodesToHeadObj(slots.default()));\n        head.addHeadObjs(obj);\n        if (IS_BROWSER) {\n          head.updateDOM();\n        }\n      });\n      return null;\n    };\n  }\n});\n\nexport {\n  injectHead,\n  createHead,\n  useHead,\n  renderHeadToString,\n  Head\n};\n//# sourceMappingURL=chunk-34TZLNIG.js.map\n","start":1663126497448,"end":1663126497555},{"name":"vite:import-analysis","result":"import {\n  defineComponent,\n  inject,\n  onBeforeUnmount,\n  ref,\n  shallowRef,\n  unref,\n  watchEffect\n} from \"/node_modules/.vite/deps/chunk-IGCPF6BW.js?v=7d84460d\";\n\n// ../node_modules/.pnpm/@vueuse+head@0.7.10_vue@3.2.39/node_modules/@vueuse/head/dist/index.mjs\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar PROVIDE_KEY = `usehead`;\nvar HEAD_COUNT_KEY = `head:count`;\nvar HEAD_ATTRS_KEY = `data-head-attrs`;\nvar SELF_CLOSING_TAGS = [\"meta\", \"link\", \"base\"];\nvar BODY_TAG_ATTR_NAME = `data-meta-body`;\nvar createElement = (tag, attrs, document) => {\n  const el = document.createElement(tag);\n  for (const key of Object.keys(attrs)) {\n    if (key === \"body\" && attrs.body === true) {\n      el.setAttribute(BODY_TAG_ATTR_NAME, \"true\");\n    } else {\n      let value = attrs[key];\n      if (key === \"key\" || value === false) {\n        continue;\n      }\n      if (key === \"children\") {\n        el.textContent = value;\n      } else {\n        el.setAttribute(key, value);\n      }\n    }\n  }\n  return el;\n};\nvar htmlEscape = (str) => str.replace(/&/g, \"&amp;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#39;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\nvar stringifyAttrs = (attributes) => {\n  const handledAttributes = [];\n  for (let [key, value] of Object.entries(attributes)) {\n    if (key === \"children\" || key === \"key\") {\n      continue;\n    }\n    if (value === false || value == null) {\n      continue;\n    }\n    let attribute = htmlEscape(key);\n    if (value !== true) {\n      attribute += `=\"${htmlEscape(String(value))}\"`;\n    }\n    handledAttributes.push(attribute);\n  }\n  return handledAttributes.length > 0 ? \" \" + handledAttributes.join(\" \") : \"\";\n};\nfunction isEqualNode(oldTag, newTag) {\n  if (oldTag instanceof HTMLElement && newTag instanceof HTMLElement) {\n    const nonce = newTag.getAttribute(\"nonce\");\n    if (nonce && !oldTag.getAttribute(\"nonce\")) {\n      const cloneTag = newTag.cloneNode(true);\n      cloneTag.setAttribute(\"nonce\", \"\");\n      cloneTag.nonce = nonce;\n      return nonce === oldTag.nonce && oldTag.isEqualNode(cloneTag);\n    }\n  }\n  return oldTag.isEqualNode(newTag);\n}\nvar getTagKey = (props) => {\n  const names = [\"key\", \"id\", \"name\", \"property\"];\n  for (const n of names) {\n    const value = typeof props.getAttribute === \"function\" ? props.hasAttribute(n) ? props.getAttribute(n) : void 0 : props[n];\n    if (value !== void 0) {\n      return { name: n, value };\n    }\n  }\n};\nvar injectHead = () => {\n  const head = inject(PROVIDE_KEY);\n  if (!head) {\n    throw new Error(`You may forget to apply app.use(head)`);\n  }\n  return head;\n};\nvar acceptFields = [\n  \"title\",\n  \"meta\",\n  \"link\",\n  \"base\",\n  \"style\",\n  \"script\",\n  \"noscript\",\n  \"htmlAttrs\",\n  \"bodyAttrs\"\n];\nvar renderTemplate = (template, title) => {\n  if (template == null)\n    return \"\";\n  if (typeof template === \"string\") {\n    return template.replace(\"%s\", title != null ? title : \"\");\n  }\n  return template(unref(title));\n};\nvar headObjToTags = (obj) => {\n  const tags = [];\n  const keys = Object.keys(obj);\n  for (const key of keys) {\n    if (obj[key] == null)\n      continue;\n    switch (key) {\n      case \"title\":\n        tags.push({ tag: key, props: { children: obj[key] } });\n        break;\n      case \"titleTemplate\":\n        break;\n      case \"base\":\n        tags.push({ tag: key, props: __spreadValues({ key: \"default\" }, obj[key]) });\n        break;\n      default:\n        if (acceptFields.includes(key)) {\n          const value = obj[key];\n          if (Array.isArray(value)) {\n            value.forEach((item) => {\n              tags.push({ tag: key, props: item });\n            });\n          } else if (value) {\n            tags.push({ tag: key, props: value });\n          }\n        }\n        break;\n    }\n  }\n  return tags;\n};\nvar setAttrs = (el, attrs) => {\n  const existingAttrs = el.getAttribute(HEAD_ATTRS_KEY);\n  if (existingAttrs) {\n    for (const key of existingAttrs.split(\",\")) {\n      if (!(key in attrs)) {\n        el.removeAttribute(key);\n      }\n    }\n  }\n  const keys = [];\n  for (const key in attrs) {\n    const value = attrs[key];\n    if (value == null)\n      continue;\n    if (value === false) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, value);\n    }\n    keys.push(key);\n  }\n  if (keys.length) {\n    el.setAttribute(HEAD_ATTRS_KEY, keys.join(\",\"));\n  } else {\n    el.removeAttribute(HEAD_ATTRS_KEY);\n  }\n};\nvar updateElements = (document = window.document, type, tags) => {\n  var _a, _b;\n  const head = document.head;\n  const body = document.body;\n  let headCountEl = head.querySelector(`meta[name=\"${HEAD_COUNT_KEY}\"]`);\n  let bodyMetaElements = body.querySelectorAll(`[${BODY_TAG_ATTR_NAME}]`);\n  const headCount = headCountEl ? Number(headCountEl.getAttribute(\"content\")) : 0;\n  const oldHeadElements = [];\n  const oldBodyElements = [];\n  if (bodyMetaElements) {\n    for (let i = 0; i < bodyMetaElements.length; i++) {\n      if (bodyMetaElements[i] && ((_a = bodyMetaElements[i].tagName) == null ? void 0 : _a.toLowerCase()) === type) {\n        oldBodyElements.push(bodyMetaElements[i]);\n      }\n    }\n  }\n  if (headCountEl) {\n    for (let i = 0, j = headCountEl.previousElementSibling; i < headCount; i++, j = (j == null ? void 0 : j.previousElementSibling) || null) {\n      if (((_b = j == null ? void 0 : j.tagName) == null ? void 0 : _b.toLowerCase()) === type) {\n        oldHeadElements.push(j);\n      }\n    }\n  } else {\n    headCountEl = document.createElement(\"meta\");\n    headCountEl.setAttribute(\"name\", HEAD_COUNT_KEY);\n    headCountEl.setAttribute(\"content\", \"0\");\n    head.append(headCountEl);\n  }\n  let newElements = tags.map((tag) => {\n    var _a2;\n    return {\n      element: createElement(tag.tag, tag.props, document),\n      body: (_a2 = tag.props.body) != null ? _a2 : false\n    };\n  });\n  newElements = newElements.filter((newEl) => {\n    for (let i = 0; i < oldHeadElements.length; i++) {\n      const oldEl = oldHeadElements[i];\n      if (isEqualNode(oldEl, newEl.element)) {\n        oldHeadElements.splice(i, 1);\n        return false;\n      }\n    }\n    for (let i = 0; i < oldBodyElements.length; i++) {\n      const oldEl = oldBodyElements[i];\n      if (isEqualNode(oldEl, newEl.element)) {\n        oldBodyElements.splice(i, 1);\n        return false;\n      }\n    }\n    return true;\n  });\n  oldBodyElements.forEach((t) => {\n    var _a2;\n    return (_a2 = t.parentNode) == null ? void 0 : _a2.removeChild(t);\n  });\n  oldHeadElements.forEach((t) => {\n    var _a2;\n    return (_a2 = t.parentNode) == null ? void 0 : _a2.removeChild(t);\n  });\n  newElements.forEach((t) => {\n    if (t.body === true) {\n      body.insertAdjacentElement(\"beforeend\", t.element);\n    } else {\n      head.insertBefore(t.element, headCountEl);\n    }\n  });\n  headCountEl.setAttribute(\"content\", \"\" + (headCount - oldHeadElements.length + newElements.filter((t) => !t.body).length));\n};\nvar createHead = (initHeadObject) => {\n  let allHeadObjs = [];\n  let previousTags = /* @__PURE__ */ new Set();\n  if (initHeadObject) {\n    allHeadObjs.push(shallowRef(initHeadObject));\n  }\n  const head = {\n    install(app) {\n      app.config.globalProperties.$head = head;\n      app.provide(PROVIDE_KEY, head);\n    },\n    get headTags() {\n      const deduped = [];\n      const titleTemplate = allHeadObjs.map((i) => unref(i).titleTemplate).reverse().find((i) => i != null);\n      allHeadObjs.forEach((objs) => {\n        const tags = headObjToTags(unref(objs));\n        tags.forEach((tag) => {\n          if (tag.tag === \"meta\" || tag.tag === \"base\" || tag.tag === \"script\") {\n            const key = getTagKey(tag.props);\n            if (key) {\n              let index = -1;\n              for (let i = 0; i < deduped.length; i++) {\n                const prev = deduped[i];\n                const prevValue = prev.props[key.name];\n                const nextValue = tag.props[key.name];\n                if (prev.tag === tag.tag && prevValue === nextValue) {\n                  index = i;\n                  break;\n                }\n              }\n              if (index !== -1) {\n                deduped.splice(index, 1);\n              }\n            }\n          }\n          if (titleTemplate && tag.tag === \"title\") {\n            tag.props.children = renderTemplate(titleTemplate, tag.props.children);\n          }\n          deduped.push(tag);\n        });\n      });\n      return deduped;\n    },\n    addHeadObjs(objs) {\n      allHeadObjs.push(objs);\n    },\n    removeHeadObjs(objs) {\n      allHeadObjs = allHeadObjs.filter((_objs) => _objs !== objs);\n    },\n    updateDOM(document = window.document) {\n      let title;\n      let htmlAttrs = {};\n      let bodyAttrs = {};\n      const actualTags = {};\n      for (const tag of head.headTags) {\n        if (tag.tag === \"title\") {\n          title = tag.props.children;\n          continue;\n        }\n        if (tag.tag === \"htmlAttrs\") {\n          Object.assign(htmlAttrs, tag.props);\n          continue;\n        }\n        if (tag.tag === \"bodyAttrs\") {\n          Object.assign(bodyAttrs, tag.props);\n          continue;\n        }\n        actualTags[tag.tag] = actualTags[tag.tag] || [];\n        actualTags[tag.tag].push(tag);\n      }\n      if (title !== void 0) {\n        document.title = title;\n      }\n      setAttrs(document.documentElement, htmlAttrs);\n      setAttrs(document.body, bodyAttrs);\n      const tags = /* @__PURE__ */ new Set([...Object.keys(actualTags), ...previousTags]);\n      for (const tag of tags) {\n        updateElements(document, tag, actualTags[tag] || []);\n      }\n      previousTags.clear();\n      Object.keys(actualTags).forEach((i) => previousTags.add(i));\n    }\n  };\n  return head;\n};\nvar IS_BROWSER = typeof window !== \"undefined\";\nvar useHead = (obj) => {\n  const head = injectHead();\n  const headObj = ref(obj);\n  head.addHeadObjs(headObj);\n  if (IS_BROWSER) {\n    watchEffect(() => {\n      head.updateDOM();\n    });\n    onBeforeUnmount(() => {\n      head.removeHeadObjs(headObj);\n      head.updateDOM();\n    });\n  }\n};\nvar tagToString = (tag) => {\n  let isBodyTag = false;\n  if (tag.props.body) {\n    isBodyTag = true;\n    delete tag.props.body;\n  }\n  let attrs = stringifyAttrs(tag.props);\n  if (SELF_CLOSING_TAGS.includes(tag.tag)) {\n    return `<${tag.tag}${attrs}${isBodyTag ? `  ${BODY_TAG_ATTR_NAME}=\"true\"` : \"\"}>`;\n  }\n  return `<${tag.tag}${attrs}${isBodyTag ? ` ${BODY_TAG_ATTR_NAME}=\"true\"` : \"\"}>${tag.props.children || \"\"}</${tag.tag}>`;\n};\nvar renderHeadToString = (head) => {\n  const tags = [];\n  let titleTag = \"\";\n  let htmlAttrs = {};\n  let bodyAttrs = {};\n  let bodyTags = [];\n  for (const tag of head.headTags) {\n    if (tag.tag === \"title\") {\n      titleTag = tagToString(tag);\n    } else if (tag.tag === \"htmlAttrs\") {\n      Object.assign(htmlAttrs, tag.props);\n    } else if (tag.tag === \"bodyAttrs\") {\n      Object.assign(bodyAttrs, tag.props);\n    } else if (tag.props.body) {\n      bodyTags.push(tagToString(tag));\n    } else {\n      tags.push(tagToString(tag));\n    }\n  }\n  tags.push(`<meta name=\"${HEAD_COUNT_KEY}\" content=\"${tags.length}\">`);\n  return {\n    get headTags() {\n      return titleTag + tags.join(\"\");\n    },\n    get htmlAttrs() {\n      return stringifyAttrs(__spreadProps(__spreadValues({}, htmlAttrs), {\n        [HEAD_ATTRS_KEY]: Object.keys(htmlAttrs).join(\",\")\n      }));\n    },\n    get bodyAttrs() {\n      return stringifyAttrs(__spreadProps(__spreadValues({}, bodyAttrs), {\n        [HEAD_ATTRS_KEY]: Object.keys(bodyAttrs).join(\",\")\n      }));\n    },\n    get bodyTags() {\n      return bodyTags.join(\"\");\n    }\n  };\n};\nvar addVNodeToHeadObj = (node, obj) => {\n  const type = node.type === \"html\" ? \"htmlAttrs\" : node.type === \"body\" ? \"bodyAttrs\" : node.type;\n  if (typeof type !== \"string\" || !(type in obj))\n    return;\n  const props = __spreadProps(__spreadValues({}, node.props), {\n    children: Array.isArray(node.children) ? node.children[0].children : node.children\n  });\n  if (Array.isArray(obj[type])) {\n    ;\n    obj[type].push(props);\n  } else if (type === \"title\") {\n    obj.title = props.children;\n  } else {\n    ;\n    obj[type] = props;\n  }\n};\nvar vnodesToHeadObj = (nodes) => {\n  const obj = {\n    title: void 0,\n    htmlAttrs: void 0,\n    bodyAttrs: void 0,\n    base: void 0,\n    meta: [],\n    link: [],\n    style: [],\n    script: [],\n    noscript: []\n  };\n  for (const node of nodes) {\n    if (typeof node.type === \"symbol\" && Array.isArray(node.children)) {\n      for (const childNode of node.children) {\n        addVNodeToHeadObj(childNode, obj);\n      }\n    } else {\n      addVNodeToHeadObj(node, obj);\n    }\n  }\n  return obj;\n};\nvar Head = defineComponent({\n  name: \"Head\",\n  setup(_, { slots }) {\n    const head = injectHead();\n    let obj;\n    onBeforeUnmount(() => {\n      if (obj) {\n        head.removeHeadObjs(obj);\n        head.updateDOM();\n      }\n    });\n    return () => {\n      watchEffect(() => {\n        if (!slots.default)\n          return;\n        if (obj) {\n          head.removeHeadObjs(obj);\n        }\n        obj = ref(vnodesToHeadObj(slots.default()));\n        head.addHeadObjs(obj);\n        if (IS_BROWSER) {\n          head.updateDOM();\n        }\n      });\n      return null;\n    };\n  }\n});\n\nexport {\n  injectHead,\n  createHead,\n  useHead,\n  renderHeadToString,\n  Head\n};\n//# sourceMappingURL=chunk-34TZLNIG.js.map\n","start":1663126497555,"end":1663126497555,"order":"normal"}]}
