{"resolvedId":"/Users/bryce/i/vue3-page-transition/playground/node_modules/.vite/deps/chunk-L5H4ESUF.js?v=7d84460d","transforms":[{"name":"vite:optimized-deps","result":"import {\n  computed,\n  defineComponent,\n  getCurrentInstance,\n  h,\n  inject,\n  nextTick,\n  onActivated,\n  onDeactivated,\n  onUnmounted,\n  provide,\n  reactive,\n  ref,\n  shallowRef,\n  unref,\n  watch,\n  watchEffect\n} from \"./chunk-IGCPF6BW.js\";\n\n// ../node_modules/.pnpm/@vue+devtools-api@6.1.4/node_modules/@vue/devtools-api/lib/esm/env.js\nfunction getDevtoolsGlobalHook() {\n  return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;\n}\nfunction getTarget() {\n  return typeof navigator !== \"undefined\" && typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {};\n}\nvar isProxyAvailable = typeof Proxy === \"function\";\n\n// ../node_modules/.pnpm/@vue+devtools-api@6.1.4/node_modules/@vue/devtools-api/lib/esm/const.js\nvar HOOK_SETUP = \"devtools-plugin:setup\";\nvar HOOK_PLUGIN_SETTINGS_SET = \"plugin:settings:set\";\n\n// ../node_modules/.pnpm/@vue+devtools-api@6.1.4/node_modules/@vue/devtools-api/lib/esm/time.js\nvar supported;\nvar perf;\nfunction isPerformanceSupported() {\n  var _a;\n  if (supported !== void 0) {\n    return supported;\n  }\n  if (typeof window !== \"undefined\" && window.performance) {\n    supported = true;\n    perf = window.performance;\n  } else if (typeof global !== \"undefined\" && ((_a = global.perf_hooks) === null || _a === void 0 ? void 0 : _a.performance)) {\n    supported = true;\n    perf = global.perf_hooks.performance;\n  } else {\n    supported = false;\n  }\n  return supported;\n}\nfunction now() {\n  return isPerformanceSupported() ? perf.now() : Date.now();\n}\n\n// ../node_modules/.pnpm/@vue+devtools-api@6.1.4/node_modules/@vue/devtools-api/lib/esm/proxy.js\nvar ApiProxy = class {\n  constructor(plugin, hook) {\n    this.target = null;\n    this.targetQueue = [];\n    this.onQueue = [];\n    this.plugin = plugin;\n    this.hook = hook;\n    const defaultSettings = {};\n    if (plugin.settings) {\n      for (const id in plugin.settings) {\n        const item = plugin.settings[id];\n        defaultSettings[id] = item.defaultValue;\n      }\n    }\n    const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;\n    let currentSettings = Object.assign({}, defaultSettings);\n    try {\n      const raw = localStorage.getItem(localSettingsSaveId);\n      const data = JSON.parse(raw);\n      Object.assign(currentSettings, data);\n    } catch (e) {\n    }\n    this.fallbacks = {\n      getSettings() {\n        return currentSettings;\n      },\n      setSettings(value) {\n        try {\n          localStorage.setItem(localSettingsSaveId, JSON.stringify(value));\n        } catch (e) {\n        }\n        currentSettings = value;\n      },\n      now() {\n        return now();\n      }\n    };\n    if (hook) {\n      hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {\n        if (pluginId === this.plugin.id) {\n          this.fallbacks.setSettings(value);\n        }\n      });\n    }\n    this.proxiedOn = new Proxy({}, {\n      get: (_target, prop) => {\n        if (this.target) {\n          return this.target.on[prop];\n        } else {\n          return (...args) => {\n            this.onQueue.push({\n              method: prop,\n              args\n            });\n          };\n        }\n      }\n    });\n    this.proxiedTarget = new Proxy({}, {\n      get: (_target, prop) => {\n        if (this.target) {\n          return this.target[prop];\n        } else if (prop === \"on\") {\n          return this.proxiedOn;\n        } else if (Object.keys(this.fallbacks).includes(prop)) {\n          return (...args) => {\n            this.targetQueue.push({\n              method: prop,\n              args,\n              resolve: () => {\n              }\n            });\n            return this.fallbacks[prop](...args);\n          };\n        } else {\n          return (...args) => {\n            return new Promise((resolve) => {\n              this.targetQueue.push({\n                method: prop,\n                args,\n                resolve\n              });\n            });\n          };\n        }\n      }\n    });\n  }\n  async setRealTarget(target) {\n    this.target = target;\n    for (const item of this.onQueue) {\n      this.target.on[item.method](...item.args);\n    }\n    for (const item of this.targetQueue) {\n      item.resolve(await this.target[item.method](...item.args));\n    }\n  }\n};\n\n// ../node_modules/.pnpm/@vue+devtools-api@6.1.4/node_modules/@vue/devtools-api/lib/esm/index.js\nfunction setupDevtoolsPlugin(pluginDescriptor, setupFn) {\n  const descriptor = pluginDescriptor;\n  const target = getTarget();\n  const hook = getDevtoolsGlobalHook();\n  const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;\n  if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {\n    hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);\n  } else {\n    const proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;\n    const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];\n    list.push({\n      pluginDescriptor: descriptor,\n      setupFn,\n      proxy\n    });\n    if (proxy)\n      setupFn(proxy.proxiedTarget);\n  }\n}\n\n// ../node_modules/.pnpm/vue-router@4.1.5_vue@3.2.39/node_modules/vue-router/dist/vue-router.mjs\nvar isBrowser = typeof window !== \"undefined\";\nfunction isESModule(obj) {\n  return obj.__esModule || obj[Symbol.toStringTag] === \"Module\";\n}\nvar assign = Object.assign;\nfunction applyToParams(fn, params) {\n  const newParams = {};\n  for (const key in params) {\n    const value = params[key];\n    newParams[key] = isArray(value) ? value.map(fn) : fn(value);\n  }\n  return newParams;\n}\nvar noop = () => {\n};\nvar isArray = Array.isArray;\nfunction warn(msg) {\n  const args = Array.from(arguments).slice(1);\n  console.warn.apply(console, [\"[Vue Router warn]: \" + msg].concat(args));\n}\nvar TRAILING_SLASH_RE = /\\/$/;\nvar removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, \"\");\nfunction parseURL(parseQuery2, location2, currentLocation = \"/\") {\n  let path, query = {}, searchString = \"\", hash = \"\";\n  const hashPos = location2.indexOf(\"#\");\n  let searchPos = location2.indexOf(\"?\");\n  if (hashPos < searchPos && hashPos >= 0) {\n    searchPos = -1;\n  }\n  if (searchPos > -1) {\n    path = location2.slice(0, searchPos);\n    searchString = location2.slice(searchPos + 1, hashPos > -1 ? hashPos : location2.length);\n    query = parseQuery2(searchString);\n  }\n  if (hashPos > -1) {\n    path = path || location2.slice(0, hashPos);\n    hash = location2.slice(hashPos, location2.length);\n  }\n  path = resolveRelativePath(path != null ? path : location2, currentLocation);\n  return {\n    fullPath: path + (searchString && \"?\") + searchString + hash,\n    path,\n    query,\n    hash\n  };\n}\nfunction stringifyURL(stringifyQuery2, location2) {\n  const query = location2.query ? stringifyQuery2(location2.query) : \"\";\n  return location2.path + (query && \"?\") + query + (location2.hash || \"\");\n}\nfunction stripBase(pathname, base) {\n  if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase()))\n    return pathname;\n  return pathname.slice(base.length) || \"/\";\n}\nfunction isSameRouteLocation(stringifyQuery2, a, b) {\n  const aLastIndex = a.matched.length - 1;\n  const bLastIndex = b.matched.length - 1;\n  return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) && isSameRouteLocationParams(a.params, b.params) && stringifyQuery2(a.query) === stringifyQuery2(b.query) && a.hash === b.hash;\n}\nfunction isSameRouteRecord(a, b) {\n  return (a.aliasOf || a) === (b.aliasOf || b);\n}\nfunction isSameRouteLocationParams(a, b) {\n  if (Object.keys(a).length !== Object.keys(b).length)\n    return false;\n  for (const key in a) {\n    if (!isSameRouteLocationParamsValue(a[key], b[key]))\n      return false;\n  }\n  return true;\n}\nfunction isSameRouteLocationParamsValue(a, b) {\n  return isArray(a) ? isEquivalentArray(a, b) : isArray(b) ? isEquivalentArray(b, a) : a === b;\n}\nfunction isEquivalentArray(a, b) {\n  return isArray(b) ? a.length === b.length && a.every((value, i) => value === b[i]) : a.length === 1 && a[0] === b;\n}\nfunction resolveRelativePath(to, from) {\n  if (to.startsWith(\"/\"))\n    return to;\n  if (!from.startsWith(\"/\")) {\n    warn(`Cannot resolve a relative location without an absolute path. Trying to resolve \"${to}\" from \"${from}\". It should look like \"/${from}\".`);\n    return to;\n  }\n  if (!to)\n    return from;\n  const fromSegments = from.split(\"/\");\n  const toSegments = to.split(\"/\");\n  let position = fromSegments.length - 1;\n  let toPosition;\n  let segment;\n  for (toPosition = 0; toPosition < toSegments.length; toPosition++) {\n    segment = toSegments[toPosition];\n    if (segment === \".\")\n      continue;\n    if (segment === \"..\") {\n      if (position > 1)\n        position--;\n    } else\n      break;\n  }\n  return fromSegments.slice(0, position).join(\"/\") + \"/\" + toSegments.slice(toPosition - (toPosition === toSegments.length ? 1 : 0)).join(\"/\");\n}\nvar NavigationType;\n(function(NavigationType2) {\n  NavigationType2[\"pop\"] = \"pop\";\n  NavigationType2[\"push\"] = \"push\";\n})(NavigationType || (NavigationType = {}));\nvar NavigationDirection;\n(function(NavigationDirection2) {\n  NavigationDirection2[\"back\"] = \"back\";\n  NavigationDirection2[\"forward\"] = \"forward\";\n  NavigationDirection2[\"unknown\"] = \"\";\n})(NavigationDirection || (NavigationDirection = {}));\nvar START = \"\";\nfunction normalizeBase(base) {\n  if (!base) {\n    if (isBrowser) {\n      const baseEl = document.querySelector(\"base\");\n      base = baseEl && baseEl.getAttribute(\"href\") || \"/\";\n      base = base.replace(/^\\w+:\\/\\/[^\\/]+/, \"\");\n    } else {\n      base = \"/\";\n    }\n  }\n  if (base[0] !== \"/\" && base[0] !== \"#\")\n    base = \"/\" + base;\n  return removeTrailingSlash(base);\n}\nvar BEFORE_HASH_RE = /^[^#]+#/;\nfunction createHref(base, location2) {\n  return base.replace(BEFORE_HASH_RE, \"#\") + location2;\n}\nfunction getElementPosition(el, offset) {\n  const docRect = document.documentElement.getBoundingClientRect();\n  const elRect = el.getBoundingClientRect();\n  return {\n    behavior: offset.behavior,\n    left: elRect.left - docRect.left - (offset.left || 0),\n    top: elRect.top - docRect.top - (offset.top || 0)\n  };\n}\nvar computeScrollPosition = () => ({\n  left: window.pageXOffset,\n  top: window.pageYOffset\n});\nfunction scrollToPosition(position) {\n  let scrollToOptions;\n  if (\"el\" in position) {\n    const positionEl = position.el;\n    const isIdSelector = typeof positionEl === \"string\" && positionEl.startsWith(\"#\");\n    if (typeof position.el === \"string\") {\n      if (!isIdSelector || !document.getElementById(position.el.slice(1))) {\n        try {\n          const foundEl = document.querySelector(position.el);\n          if (isIdSelector && foundEl) {\n            warn(`The selector \"${position.el}\" should be passed as \"el: document.querySelector('${position.el}')\" because it starts with \"#\".`);\n            return;\n          }\n        } catch (err) {\n          warn(`The selector \"${position.el}\" is invalid. If you are using an id selector, make sure to escape it. You can find more information about escaping characters in selectors at https://mathiasbynens.be/notes/css-escapes or use CSS.escape (https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape).`);\n          return;\n        }\n      }\n    }\n    const el = typeof positionEl === \"string\" ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;\n    if (!el) {\n      warn(`Couldn't find element using selector \"${position.el}\" returned by scrollBehavior.`);\n      return;\n    }\n    scrollToOptions = getElementPosition(el, position);\n  } else {\n    scrollToOptions = position;\n  }\n  if (\"scrollBehavior\" in document.documentElement.style)\n    window.scrollTo(scrollToOptions);\n  else {\n    window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset, scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset);\n  }\n}\nfunction getScrollKey(path, delta) {\n  const position = history.state ? history.state.position - delta : -1;\n  return position + path;\n}\nvar scrollPositions = /* @__PURE__ */ new Map();\nfunction saveScrollPosition(key, scrollPosition) {\n  scrollPositions.set(key, scrollPosition);\n}\nfunction getSavedScrollPosition(key) {\n  const scroll = scrollPositions.get(key);\n  scrollPositions.delete(key);\n  return scroll;\n}\nvar createBaseLocation = () => location.protocol + \"//\" + location.host;\nfunction createCurrentLocation(base, location2) {\n  const { pathname, search, hash } = location2;\n  const hashPos = base.indexOf(\"#\");\n  if (hashPos > -1) {\n    let slicePos = hash.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;\n    let pathFromHash = hash.slice(slicePos);\n    if (pathFromHash[0] !== \"/\")\n      pathFromHash = \"/\" + pathFromHash;\n    return stripBase(pathFromHash, \"\");\n  }\n  const path = stripBase(pathname, base);\n  return path + search + hash;\n}\nfunction useHistoryListeners(base, historyState, currentLocation, replace) {\n  let listeners = [];\n  let teardowns = [];\n  let pauseState = null;\n  const popStateHandler = ({ state }) => {\n    const to = createCurrentLocation(base, location);\n    const from = currentLocation.value;\n    const fromState = historyState.value;\n    let delta = 0;\n    if (state) {\n      currentLocation.value = to;\n      historyState.value = state;\n      if (pauseState && pauseState === from) {\n        pauseState = null;\n        return;\n      }\n      delta = fromState ? state.position - fromState.position : 0;\n    } else {\n      replace(to);\n    }\n    listeners.forEach((listener) => {\n      listener(currentLocation.value, from, {\n        delta,\n        type: NavigationType.pop,\n        direction: delta ? delta > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown\n      });\n    });\n  };\n  function pauseListeners() {\n    pauseState = currentLocation.value;\n  }\n  function listen(callback) {\n    listeners.push(callback);\n    const teardown = () => {\n      const index = listeners.indexOf(callback);\n      if (index > -1)\n        listeners.splice(index, 1);\n    };\n    teardowns.push(teardown);\n    return teardown;\n  }\n  function beforeUnloadListener() {\n    const { history: history2 } = window;\n    if (!history2.state)\n      return;\n    history2.replaceState(assign({}, history2.state, { scroll: computeScrollPosition() }), \"\");\n  }\n  function destroy() {\n    for (const teardown of teardowns)\n      teardown();\n    teardowns = [];\n    window.removeEventListener(\"popstate\", popStateHandler);\n    window.removeEventListener(\"beforeunload\", beforeUnloadListener);\n  }\n  window.addEventListener(\"popstate\", popStateHandler);\n  window.addEventListener(\"beforeunload\", beforeUnloadListener);\n  return {\n    pauseListeners,\n    listen,\n    destroy\n  };\n}\nfunction buildState(back, current, forward, replaced = false, computeScroll = false) {\n  return {\n    back,\n    current,\n    forward,\n    replaced,\n    position: window.history.length,\n    scroll: computeScroll ? computeScrollPosition() : null\n  };\n}\nfunction useHistoryStateNavigation(base) {\n  const { history: history2, location: location2 } = window;\n  const currentLocation = {\n    value: createCurrentLocation(base, location2)\n  };\n  const historyState = { value: history2.state };\n  if (!historyState.value) {\n    changeLocation(currentLocation.value, {\n      back: null,\n      current: currentLocation.value,\n      forward: null,\n      position: history2.length - 1,\n      replaced: true,\n      scroll: null\n    }, true);\n  }\n  function changeLocation(to, state, replace2) {\n    const hashIndex = base.indexOf(\"#\");\n    const url = hashIndex > -1 ? (location2.host && document.querySelector(\"base\") ? base : base.slice(hashIndex)) + to : createBaseLocation() + base + to;\n    try {\n      history2[replace2 ? \"replaceState\" : \"pushState\"](state, \"\", url);\n      historyState.value = state;\n    } catch (err) {\n      if (true) {\n        warn(\"Error with push/replace State\", err);\n      } else {\n        console.error(err);\n      }\n      location2[replace2 ? \"replace\" : \"assign\"](url);\n    }\n  }\n  function replace(to, data) {\n    const state = assign({}, history2.state, buildState(\n      historyState.value.back,\n      to,\n      historyState.value.forward,\n      true\n    ), data, { position: historyState.value.position });\n    changeLocation(to, state, true);\n    currentLocation.value = to;\n  }\n  function push(to, data) {\n    const currentState = assign(\n      {},\n      historyState.value,\n      history2.state,\n      {\n        forward: to,\n        scroll: computeScrollPosition()\n      }\n    );\n    if (!history2.state) {\n      warn(`history.state seems to have been manually replaced without preserving the necessary values. Make sure to preserve existing history state if you are manually calling history.replaceState:\n\nhistory.replaceState(history.state, '', url)\n\nYou can find more information at https://next.router.vuejs.org/guide/migration/#usage-of-history-state.`);\n    }\n    changeLocation(currentState.current, currentState, true);\n    const state = assign({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data);\n    changeLocation(to, state, false);\n    currentLocation.value = to;\n  }\n  return {\n    location: currentLocation,\n    state: historyState,\n    push,\n    replace\n  };\n}\nfunction createWebHistory(base) {\n  base = normalizeBase(base);\n  const historyNavigation = useHistoryStateNavigation(base);\n  const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);\n  function go(delta, triggerListeners = true) {\n    if (!triggerListeners)\n      historyListeners.pauseListeners();\n    history.go(delta);\n  }\n  const routerHistory = assign({\n    location: \"\",\n    base,\n    go,\n    createHref: createHref.bind(null, base)\n  }, historyNavigation, historyListeners);\n  Object.defineProperty(routerHistory, \"location\", {\n    enumerable: true,\n    get: () => historyNavigation.location.value\n  });\n  Object.defineProperty(routerHistory, \"state\", {\n    enumerable: true,\n    get: () => historyNavigation.state.value\n  });\n  return routerHistory;\n}\nfunction createMemoryHistory(base = \"\") {\n  let listeners = [];\n  let queue = [START];\n  let position = 0;\n  base = normalizeBase(base);\n  function setLocation(location2) {\n    position++;\n    if (position === queue.length) {\n      queue.push(location2);\n    } else {\n      queue.splice(position);\n      queue.push(location2);\n    }\n  }\n  function triggerListeners(to, from, { direction, delta }) {\n    const info = {\n      direction,\n      delta,\n      type: NavigationType.pop\n    };\n    for (const callback of listeners) {\n      callback(to, from, info);\n    }\n  }\n  const routerHistory = {\n    location: START,\n    state: {},\n    base,\n    createHref: createHref.bind(null, base),\n    replace(to) {\n      queue.splice(position--, 1);\n      setLocation(to);\n    },\n    push(to, data) {\n      setLocation(to);\n    },\n    listen(callback) {\n      listeners.push(callback);\n      return () => {\n        const index = listeners.indexOf(callback);\n        if (index > -1)\n          listeners.splice(index, 1);\n      };\n    },\n    destroy() {\n      listeners = [];\n      queue = [START];\n      position = 0;\n    },\n    go(delta, shouldTrigger = true) {\n      const from = this.location;\n      const direction = delta < 0 ? NavigationDirection.back : NavigationDirection.forward;\n      position = Math.max(0, Math.min(position + delta, queue.length - 1));\n      if (shouldTrigger) {\n        triggerListeners(this.location, from, {\n          direction,\n          delta\n        });\n      }\n    }\n  };\n  Object.defineProperty(routerHistory, \"location\", {\n    enumerable: true,\n    get: () => queue[position]\n  });\n  return routerHistory;\n}\nfunction createWebHashHistory(base) {\n  base = location.host ? base || location.pathname + location.search : \"\";\n  if (!base.includes(\"#\"))\n    base += \"#\";\n  if (!base.endsWith(\"#/\") && !base.endsWith(\"#\")) {\n    warn(`A hash base must end with a \"#\":\n\"${base}\" should be \"${base.replace(/#.*$/, \"#\")}\".`);\n  }\n  return createWebHistory(base);\n}\nfunction isRouteLocation(route) {\n  return typeof route === \"string\" || route && typeof route === \"object\";\n}\nfunction isRouteName(name) {\n  return typeof name === \"string\" || typeof name === \"symbol\";\n}\nvar START_LOCATION_NORMALIZED = {\n  path: \"/\",\n  name: void 0,\n  params: {},\n  query: {},\n  hash: \"\",\n  fullPath: \"/\",\n  matched: [],\n  meta: {},\n  redirectedFrom: void 0\n};\nvar NavigationFailureSymbol = Symbol(true ? \"navigation failure\" : \"\");\nvar NavigationFailureType;\n(function(NavigationFailureType2) {\n  NavigationFailureType2[NavigationFailureType2[\"aborted\"] = 4] = \"aborted\";\n  NavigationFailureType2[NavigationFailureType2[\"cancelled\"] = 8] = \"cancelled\";\n  NavigationFailureType2[NavigationFailureType2[\"duplicated\"] = 16] = \"duplicated\";\n})(NavigationFailureType || (NavigationFailureType = {}));\nvar ErrorTypeMessages = {\n  [1]({ location: location2, currentLocation }) {\n    return `No match for\n ${JSON.stringify(location2)}${currentLocation ? \"\\nwhile being at\\n\" + JSON.stringify(currentLocation) : \"\"}`;\n  },\n  [2]({ from, to }) {\n    return `Redirected from \"${from.fullPath}\" to \"${stringifyRoute(to)}\" via a navigation guard.`;\n  },\n  [4]({ from, to }) {\n    return `Navigation aborted from \"${from.fullPath}\" to \"${to.fullPath}\" via a navigation guard.`;\n  },\n  [8]({ from, to }) {\n    return `Navigation cancelled from \"${from.fullPath}\" to \"${to.fullPath}\" with a new navigation.`;\n  },\n  [16]({ from, to }) {\n    return `Avoided redundant navigation to current location: \"${from.fullPath}\".`;\n  }\n};\nfunction createRouterError(type, params) {\n  if (true) {\n    return assign(new Error(ErrorTypeMessages[type](params)), {\n      type,\n      [NavigationFailureSymbol]: true\n    }, params);\n  } else {\n    return assign(new Error(), {\n      type,\n      [NavigationFailureSymbol]: true\n    }, params);\n  }\n}\nfunction isNavigationFailure(error, type) {\n  return error instanceof Error && NavigationFailureSymbol in error && (type == null || !!(error.type & type));\n}\nvar propertiesToLog = [\"params\", \"query\", \"hash\"];\nfunction stringifyRoute(to) {\n  if (typeof to === \"string\")\n    return to;\n  if (\"path\" in to)\n    return to.path;\n  const location2 = {};\n  for (const key of propertiesToLog) {\n    if (key in to)\n      location2[key] = to[key];\n  }\n  return JSON.stringify(location2, null, 2);\n}\nvar BASE_PARAM_PATTERN = \"[^/]+?\";\nvar BASE_PATH_PARSER_OPTIONS = {\n  sensitive: false,\n  strict: false,\n  start: true,\n  end: true\n};\nvar REGEX_CHARS_RE = /[.+*?^${}()[\\]/\\\\]/g;\nfunction tokensToParser(segments, extraOptions) {\n  const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);\n  const score = [];\n  let pattern = options.start ? \"^\" : \"\";\n  const keys = [];\n  for (const segment of segments) {\n    const segmentScores = segment.length ? [] : [90];\n    if (options.strict && !segment.length)\n      pattern += \"/\";\n    for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {\n      const token = segment[tokenIndex];\n      let subSegmentScore = 40 + (options.sensitive ? 0.25 : 0);\n      if (token.type === 0) {\n        if (!tokenIndex)\n          pattern += \"/\";\n        pattern += token.value.replace(REGEX_CHARS_RE, \"\\\\$&\");\n        subSegmentScore += 40;\n      } else if (token.type === 1) {\n        const { value, repeatable, optional, regexp } = token;\n        keys.push({\n          name: value,\n          repeatable,\n          optional\n        });\n        const re2 = regexp ? regexp : BASE_PARAM_PATTERN;\n        if (re2 !== BASE_PARAM_PATTERN) {\n          subSegmentScore += 10;\n          try {\n            new RegExp(`(${re2})`);\n          } catch (err) {\n            throw new Error(`Invalid custom RegExp for param \"${value}\" (${re2}): ` + err.message);\n          }\n        }\n        let subPattern = repeatable ? `((?:${re2})(?:/(?:${re2}))*)` : `(${re2})`;\n        if (!tokenIndex)\n          subPattern = optional && segment.length < 2 ? `(?:/${subPattern})` : \"/\" + subPattern;\n        if (optional)\n          subPattern += \"?\";\n        pattern += subPattern;\n        subSegmentScore += 20;\n        if (optional)\n          subSegmentScore += -8;\n        if (repeatable)\n          subSegmentScore += -20;\n        if (re2 === \".*\")\n          subSegmentScore += -50;\n      }\n      segmentScores.push(subSegmentScore);\n    }\n    score.push(segmentScores);\n  }\n  if (options.strict && options.end) {\n    const i = score.length - 1;\n    score[i][score[i].length - 1] += 0.7000000000000001;\n  }\n  if (!options.strict)\n    pattern += \"/?\";\n  if (options.end)\n    pattern += \"$\";\n  else if (options.strict)\n    pattern += \"(?:/|$)\";\n  const re = new RegExp(pattern, options.sensitive ? \"\" : \"i\");\n  function parse(path) {\n    const match = path.match(re);\n    const params = {};\n    if (!match)\n      return null;\n    for (let i = 1; i < match.length; i++) {\n      const value = match[i] || \"\";\n      const key = keys[i - 1];\n      params[key.name] = value && key.repeatable ? value.split(\"/\") : value;\n    }\n    return params;\n  }\n  function stringify(params) {\n    let path = \"\";\n    let avoidDuplicatedSlash = false;\n    for (const segment of segments) {\n      if (!avoidDuplicatedSlash || !path.endsWith(\"/\"))\n        path += \"/\";\n      avoidDuplicatedSlash = false;\n      for (const token of segment) {\n        if (token.type === 0) {\n          path += token.value;\n        } else if (token.type === 1) {\n          const { value, repeatable, optional } = token;\n          const param = value in params ? params[value] : \"\";\n          if (isArray(param) && !repeatable) {\n            throw new Error(`Provided param \"${value}\" is an array but it is not repeatable (* or + modifiers)`);\n          }\n          const text = isArray(param) ? param.join(\"/\") : param;\n          if (!text) {\n            if (optional) {\n              if (segment.length < 2) {\n                if (path.endsWith(\"/\"))\n                  path = path.slice(0, -1);\n                else\n                  avoidDuplicatedSlash = true;\n              }\n            } else\n              throw new Error(`Missing required param \"${value}\"`);\n          }\n          path += text;\n        }\n      }\n    }\n    return path || \"/\";\n  }\n  return {\n    re,\n    score,\n    keys,\n    parse,\n    stringify\n  };\n}\nfunction compareScoreArray(a, b) {\n  let i = 0;\n  while (i < a.length && i < b.length) {\n    const diff = b[i] - a[i];\n    if (diff)\n      return diff;\n    i++;\n  }\n  if (a.length < b.length) {\n    return a.length === 1 && a[0] === 40 + 40 ? -1 : 1;\n  } else if (a.length > b.length) {\n    return b.length === 1 && b[0] === 40 + 40 ? 1 : -1;\n  }\n  return 0;\n}\nfunction comparePathParserScore(a, b) {\n  let i = 0;\n  const aScore = a.score;\n  const bScore = b.score;\n  while (i < aScore.length && i < bScore.length) {\n    const comp = compareScoreArray(aScore[i], bScore[i]);\n    if (comp)\n      return comp;\n    i++;\n  }\n  if (Math.abs(bScore.length - aScore.length) === 1) {\n    if (isLastScoreNegative(aScore))\n      return 1;\n    if (isLastScoreNegative(bScore))\n      return -1;\n  }\n  return bScore.length - aScore.length;\n}\nfunction isLastScoreNegative(score) {\n  const last = score[score.length - 1];\n  return score.length > 0 && last[last.length - 1] < 0;\n}\nvar ROOT_TOKEN = {\n  type: 0,\n  value: \"\"\n};\nvar VALID_PARAM_RE = /[a-zA-Z0-9_]/;\nfunction tokenizePath(path) {\n  if (!path)\n    return [[]];\n  if (path === \"/\")\n    return [[ROOT_TOKEN]];\n  if (!path.startsWith(\"/\")) {\n    throw new Error(true ? `Route paths should start with a \"/\": \"${path}\" should be \"/${path}\".` : `Invalid path \"${path}\"`);\n  }\n  function crash(message) {\n    throw new Error(`ERR (${state})/\"${buffer}\": ${message}`);\n  }\n  let state = 0;\n  let previousState = state;\n  const tokens = [];\n  let segment;\n  function finalizeSegment() {\n    if (segment)\n      tokens.push(segment);\n    segment = [];\n  }\n  let i = 0;\n  let char;\n  let buffer = \"\";\n  let customRe = \"\";\n  function consumeBuffer() {\n    if (!buffer)\n      return;\n    if (state === 0) {\n      segment.push({\n        type: 0,\n        value: buffer\n      });\n    } else if (state === 1 || state === 2 || state === 3) {\n      if (segment.length > 1 && (char === \"*\" || char === \"+\"))\n        crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);\n      segment.push({\n        type: 1,\n        value: buffer,\n        regexp: customRe,\n        repeatable: char === \"*\" || char === \"+\",\n        optional: char === \"*\" || char === \"?\"\n      });\n    } else {\n      crash(\"Invalid state to consume buffer\");\n    }\n    buffer = \"\";\n  }\n  function addCharToBuffer() {\n    buffer += char;\n  }\n  while (i < path.length) {\n    char = path[i++];\n    if (char === \"\\\\\" && state !== 2) {\n      previousState = state;\n      state = 4;\n      continue;\n    }\n    switch (state) {\n      case 0:\n        if (char === \"/\") {\n          if (buffer) {\n            consumeBuffer();\n          }\n          finalizeSegment();\n        } else if (char === \":\") {\n          consumeBuffer();\n          state = 1;\n        } else {\n          addCharToBuffer();\n        }\n        break;\n      case 4:\n        addCharToBuffer();\n        state = previousState;\n        break;\n      case 1:\n        if (char === \"(\") {\n          state = 2;\n        } else if (VALID_PARAM_RE.test(char)) {\n          addCharToBuffer();\n        } else {\n          consumeBuffer();\n          state = 0;\n          if (char !== \"*\" && char !== \"?\" && char !== \"+\")\n            i--;\n        }\n        break;\n      case 2:\n        if (char === \")\") {\n          if (customRe[customRe.length - 1] == \"\\\\\")\n            customRe = customRe.slice(0, -1) + char;\n          else\n            state = 3;\n        } else {\n          customRe += char;\n        }\n        break;\n      case 3:\n        consumeBuffer();\n        state = 0;\n        if (char !== \"*\" && char !== \"?\" && char !== \"+\")\n          i--;\n        customRe = \"\";\n        break;\n      default:\n        crash(\"Unknown state\");\n        break;\n    }\n  }\n  if (state === 2)\n    crash(`Unfinished custom RegExp for param \"${buffer}\"`);\n  consumeBuffer();\n  finalizeSegment();\n  return tokens;\n}\nfunction createRouteRecordMatcher(record, parent, options) {\n  const parser = tokensToParser(tokenizePath(record.path), options);\n  if (true) {\n    const existingKeys = /* @__PURE__ */ new Set();\n    for (const key of parser.keys) {\n      if (existingKeys.has(key.name))\n        warn(`Found duplicated params with name \"${key.name}\" for path \"${record.path}\". Only the last one will be available on \"$route.params\".`);\n      existingKeys.add(key.name);\n    }\n  }\n  const matcher = assign(parser, {\n    record,\n    parent,\n    children: [],\n    alias: []\n  });\n  if (parent) {\n    if (!matcher.record.aliasOf === !parent.record.aliasOf)\n      parent.children.push(matcher);\n  }\n  return matcher;\n}\nfunction createRouterMatcher(routes, globalOptions) {\n  const matchers = [];\n  const matcherMap = /* @__PURE__ */ new Map();\n  globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);\n  function getRecordMatcher(name) {\n    return matcherMap.get(name);\n  }\n  function addRoute(record, parent, originalRecord) {\n    const isRootAdd = !originalRecord;\n    const mainNormalizedRecord = normalizeRouteRecord(record);\n    if (true) {\n      checkChildMissingNameWithEmptyPath(mainNormalizedRecord, parent);\n    }\n    mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;\n    const options = mergeOptions(globalOptions, record);\n    const normalizedRecords = [\n      mainNormalizedRecord\n    ];\n    if (\"alias\" in record) {\n      const aliases = typeof record.alias === \"string\" ? [record.alias] : record.alias;\n      for (const alias of aliases) {\n        normalizedRecords.push(assign({}, mainNormalizedRecord, {\n          components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,\n          path: alias,\n          aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord\n        }));\n      }\n    }\n    let matcher;\n    let originalMatcher;\n    for (const normalizedRecord of normalizedRecords) {\n      const { path } = normalizedRecord;\n      if (parent && path[0] !== \"/\") {\n        const parentPath = parent.record.path;\n        const connectingSlash = parentPath[parentPath.length - 1] === \"/\" ? \"\" : \"/\";\n        normalizedRecord.path = parent.record.path + (path && connectingSlash + path);\n      }\n      if (normalizedRecord.path === \"*\") {\n        throw new Error('Catch all routes (\"*\") must now be defined using a param with a custom regexp.\\nSee more at https://next.router.vuejs.org/guide/migration/#removed-star-or-catch-all-routes.');\n      }\n      matcher = createRouteRecordMatcher(normalizedRecord, parent, options);\n      if (parent && path[0] === \"/\")\n        checkMissingParamsInAbsolutePath(matcher, parent);\n      if (originalRecord) {\n        originalRecord.alias.push(matcher);\n        if (true) {\n          checkSameParams(originalRecord, matcher);\n        }\n      } else {\n        originalMatcher = originalMatcher || matcher;\n        if (originalMatcher !== matcher)\n          originalMatcher.alias.push(matcher);\n        if (isRootAdd && record.name && !isAliasRecord(matcher))\n          removeRoute(record.name);\n      }\n      if (mainNormalizedRecord.children) {\n        const children = mainNormalizedRecord.children;\n        for (let i = 0; i < children.length; i++) {\n          addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);\n        }\n      }\n      originalRecord = originalRecord || matcher;\n      insertMatcher(matcher);\n    }\n    return originalMatcher ? () => {\n      removeRoute(originalMatcher);\n    } : noop;\n  }\n  function removeRoute(matcherRef) {\n    if (isRouteName(matcherRef)) {\n      const matcher = matcherMap.get(matcherRef);\n      if (matcher) {\n        matcherMap.delete(matcherRef);\n        matchers.splice(matchers.indexOf(matcher), 1);\n        matcher.children.forEach(removeRoute);\n        matcher.alias.forEach(removeRoute);\n      }\n    } else {\n      const index = matchers.indexOf(matcherRef);\n      if (index > -1) {\n        matchers.splice(index, 1);\n        if (matcherRef.record.name)\n          matcherMap.delete(matcherRef.record.name);\n        matcherRef.children.forEach(removeRoute);\n        matcherRef.alias.forEach(removeRoute);\n      }\n    }\n  }\n  function getRoutes() {\n    return matchers;\n  }\n  function insertMatcher(matcher) {\n    let i = 0;\n    while (i < matchers.length && comparePathParserScore(matcher, matchers[i]) >= 0 && (matcher.record.path !== matchers[i].record.path || !isRecordChildOf(matcher, matchers[i])))\n      i++;\n    matchers.splice(i, 0, matcher);\n    if (matcher.record.name && !isAliasRecord(matcher))\n      matcherMap.set(matcher.record.name, matcher);\n  }\n  function resolve(location2, currentLocation) {\n    let matcher;\n    let params = {};\n    let path;\n    let name;\n    if (\"name\" in location2 && location2.name) {\n      matcher = matcherMap.get(location2.name);\n      if (!matcher)\n        throw createRouterError(1, {\n          location: location2\n        });\n      if (true) {\n        const invalidParams = Object.keys(location2.params || {}).filter((paramName) => !matcher.keys.find((k) => k.name === paramName));\n        if (invalidParams.length) {\n          warn(`Discarded invalid param(s) \"${invalidParams.join('\", \"')}\" when navigating. See https://github.com/vuejs/router/blob/main/packages/router/CHANGELOG.md#414-2022-08-22 for more details.`);\n        }\n      }\n      name = matcher.record.name;\n      params = assign(\n        paramsFromLocation(\n          currentLocation.params,\n          matcher.keys.filter((k) => !k.optional).map((k) => k.name)\n        ),\n        location2.params && paramsFromLocation(location2.params, matcher.keys.map((k) => k.name))\n      );\n      path = matcher.stringify(params);\n    } else if (\"path\" in location2) {\n      path = location2.path;\n      if (!path.startsWith(\"/\")) {\n        warn(`The Matcher cannot resolve relative paths but received \"${path}\". Unless you directly called \\`matcher.resolve(\"${path}\")\\`, this is probably a bug in vue-router. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/router.`);\n      }\n      matcher = matchers.find((m) => m.re.test(path));\n      if (matcher) {\n        params = matcher.parse(path);\n        name = matcher.record.name;\n      }\n    } else {\n      matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers.find((m) => m.re.test(currentLocation.path));\n      if (!matcher)\n        throw createRouterError(1, {\n          location: location2,\n          currentLocation\n        });\n      name = matcher.record.name;\n      params = assign({}, currentLocation.params, location2.params);\n      path = matcher.stringify(params);\n    }\n    const matched = [];\n    let parentMatcher = matcher;\n    while (parentMatcher) {\n      matched.unshift(parentMatcher.record);\n      parentMatcher = parentMatcher.parent;\n    }\n    return {\n      name,\n      path,\n      params,\n      matched,\n      meta: mergeMetaFields(matched)\n    };\n  }\n  routes.forEach((route) => addRoute(route));\n  return { addRoute, resolve, removeRoute, getRoutes, getRecordMatcher };\n}\nfunction paramsFromLocation(params, keys) {\n  const newParams = {};\n  for (const key of keys) {\n    if (key in params)\n      newParams[key] = params[key];\n  }\n  return newParams;\n}\nfunction normalizeRouteRecord(record) {\n  return {\n    path: record.path,\n    redirect: record.redirect,\n    name: record.name,\n    meta: record.meta || {},\n    aliasOf: void 0,\n    beforeEnter: record.beforeEnter,\n    props: normalizeRecordProps(record),\n    children: record.children || [],\n    instances: {},\n    leaveGuards: /* @__PURE__ */ new Set(),\n    updateGuards: /* @__PURE__ */ new Set(),\n    enterCallbacks: {},\n    components: \"components\" in record ? record.components || null : record.component && { default: record.component }\n  };\n}\nfunction normalizeRecordProps(record) {\n  const propsObject = {};\n  const props = record.props || false;\n  if (\"component\" in record) {\n    propsObject.default = props;\n  } else {\n    for (const name in record.components)\n      propsObject[name] = typeof props === \"boolean\" ? props : props[name];\n  }\n  return propsObject;\n}\nfunction isAliasRecord(record) {\n  while (record) {\n    if (record.record.aliasOf)\n      return true;\n    record = record.parent;\n  }\n  return false;\n}\nfunction mergeMetaFields(matched) {\n  return matched.reduce((meta, record) => assign(meta, record.meta), {});\n}\nfunction mergeOptions(defaults, partialOptions) {\n  const options = {};\n  for (const key in defaults) {\n    options[key] = key in partialOptions ? partialOptions[key] : defaults[key];\n  }\n  return options;\n}\nfunction isSameParam(a, b) {\n  return a.name === b.name && a.optional === b.optional && a.repeatable === b.repeatable;\n}\nfunction checkSameParams(a, b) {\n  for (const key of a.keys) {\n    if (!key.optional && !b.keys.find(isSameParam.bind(null, key)))\n      return warn(`Alias \"${b.record.path}\" and the original record: \"${a.record.path}\" must have the exact same param named \"${key.name}\"`);\n  }\n  for (const key of b.keys) {\n    if (!key.optional && !a.keys.find(isSameParam.bind(null, key)))\n      return warn(`Alias \"${b.record.path}\" and the original record: \"${a.record.path}\" must have the exact same param named \"${key.name}\"`);\n  }\n}\nfunction checkChildMissingNameWithEmptyPath(mainNormalizedRecord, parent) {\n  if (parent && parent.record.name && !mainNormalizedRecord.name && !mainNormalizedRecord.path) {\n    warn(`The route named \"${String(parent.record.name)}\" has a child without a name and an empty path. Using that name won't render the empty path child so you probably want to move the name to the child instead. If this is intentional, add a name to the child route to remove the warning.`);\n  }\n}\nfunction checkMissingParamsInAbsolutePath(record, parent) {\n  for (const key of parent.keys) {\n    if (!record.keys.find(isSameParam.bind(null, key)))\n      return warn(`Absolute path \"${record.record.path}\" must have the exact same param named \"${key.name}\" as its parent \"${parent.record.path}\".`);\n  }\n}\nfunction isRecordChildOf(record, parent) {\n  return parent.children.some((child) => child === record || isRecordChildOf(record, child));\n}\nvar HASH_RE = /#/g;\nvar AMPERSAND_RE = /&/g;\nvar SLASH_RE = /\\//g;\nvar EQUAL_RE = /=/g;\nvar IM_RE = /\\?/g;\nvar PLUS_RE = /\\+/g;\nvar ENC_BRACKET_OPEN_RE = /%5B/g;\nvar ENC_BRACKET_CLOSE_RE = /%5D/g;\nvar ENC_CARET_RE = /%5E/g;\nvar ENC_BACKTICK_RE = /%60/g;\nvar ENC_CURLY_OPEN_RE = /%7B/g;\nvar ENC_PIPE_RE = /%7C/g;\nvar ENC_CURLY_CLOSE_RE = /%7D/g;\nvar ENC_SPACE_RE = /%20/g;\nfunction commonEncode(text) {\n  return encodeURI(\"\" + text).replace(ENC_PIPE_RE, \"|\").replace(ENC_BRACKET_OPEN_RE, \"[\").replace(ENC_BRACKET_CLOSE_RE, \"]\");\n}\nfunction encodeHash(text) {\n  return commonEncode(text).replace(ENC_CURLY_OPEN_RE, \"{\").replace(ENC_CURLY_CLOSE_RE, \"}\").replace(ENC_CARET_RE, \"^\");\n}\nfunction encodeQueryValue(text) {\n  return commonEncode(text).replace(PLUS_RE, \"%2B\").replace(ENC_SPACE_RE, \"+\").replace(HASH_RE, \"%23\").replace(AMPERSAND_RE, \"%26\").replace(ENC_BACKTICK_RE, \"`\").replace(ENC_CURLY_OPEN_RE, \"{\").replace(ENC_CURLY_CLOSE_RE, \"}\").replace(ENC_CARET_RE, \"^\");\n}\nfunction encodeQueryKey(text) {\n  return encodeQueryValue(text).replace(EQUAL_RE, \"%3D\");\n}\nfunction encodePath(text) {\n  return commonEncode(text).replace(HASH_RE, \"%23\").replace(IM_RE, \"%3F\");\n}\nfunction encodeParam(text) {\n  return text == null ? \"\" : encodePath(text).replace(SLASH_RE, \"%2F\");\n}\nfunction decode(text) {\n  try {\n    return decodeURIComponent(\"\" + text);\n  } catch (err) {\n    warn(`Error decoding \"${text}\". Using original value`);\n  }\n  return \"\" + text;\n}\nfunction parseQuery(search) {\n  const query = {};\n  if (search === \"\" || search === \"?\")\n    return query;\n  const hasLeadingIM = search[0] === \"?\";\n  const searchParams = (hasLeadingIM ? search.slice(1) : search).split(\"&\");\n  for (let i = 0; i < searchParams.length; ++i) {\n    const searchParam = searchParams[i].replace(PLUS_RE, \" \");\n    const eqPos = searchParam.indexOf(\"=\");\n    const key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));\n    const value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));\n    if (key in query) {\n      let currentValue = query[key];\n      if (!isArray(currentValue)) {\n        currentValue = query[key] = [currentValue];\n      }\n      currentValue.push(value);\n    } else {\n      query[key] = value;\n    }\n  }\n  return query;\n}\nfunction stringifyQuery(query) {\n  let search = \"\";\n  for (let key in query) {\n    const value = query[key];\n    key = encodeQueryKey(key);\n    if (value == null) {\n      if (value !== void 0) {\n        search += (search.length ? \"&\" : \"\") + key;\n      }\n      continue;\n    }\n    const values = isArray(value) ? value.map((v) => v && encodeQueryValue(v)) : [value && encodeQueryValue(value)];\n    values.forEach((value2) => {\n      if (value2 !== void 0) {\n        search += (search.length ? \"&\" : \"\") + key;\n        if (value2 != null)\n          search += \"=\" + value2;\n      }\n    });\n  }\n  return search;\n}\nfunction normalizeQuery(query) {\n  const normalizedQuery = {};\n  for (const key in query) {\n    const value = query[key];\n    if (value !== void 0) {\n      normalizedQuery[key] = isArray(value) ? value.map((v) => v == null ? null : \"\" + v) : value == null ? value : \"\" + value;\n    }\n  }\n  return normalizedQuery;\n}\nvar matchedRouteKey = Symbol(true ? \"router view location matched\" : \"\");\nvar viewDepthKey = Symbol(true ? \"router view depth\" : \"\");\nvar routerKey = Symbol(true ? \"router\" : \"\");\nvar routeLocationKey = Symbol(true ? \"route location\" : \"\");\nvar routerViewLocationKey = Symbol(true ? \"router view location\" : \"\");\nfunction useCallbacks() {\n  let handlers = [];\n  function add(handler) {\n    handlers.push(handler);\n    return () => {\n      const i = handlers.indexOf(handler);\n      if (i > -1)\n        handlers.splice(i, 1);\n    };\n  }\n  function reset() {\n    handlers = [];\n  }\n  return {\n    add,\n    list: () => handlers,\n    reset\n  };\n}\nfunction registerGuard(record, name, guard) {\n  const removeFromList = () => {\n    record[name].delete(guard);\n  };\n  onUnmounted(removeFromList);\n  onDeactivated(removeFromList);\n  onActivated(() => {\n    record[name].add(guard);\n  });\n  record[name].add(guard);\n}\nfunction onBeforeRouteLeave(leaveGuard) {\n  if (!getCurrentInstance()) {\n    warn(\"getCurrentInstance() returned null. onBeforeRouteLeave() must be called at the top of a setup function\");\n    return;\n  }\n  const activeRecord = inject(\n    matchedRouteKey,\n    {}\n  ).value;\n  if (!activeRecord) {\n    warn(\"No active route record was found when calling `onBeforeRouteLeave()`. Make sure you call this function inside a component child of <router-view>. Maybe you called it inside of App.vue?\");\n    return;\n  }\n  registerGuard(activeRecord, \"leaveGuards\", leaveGuard);\n}\nfunction onBeforeRouteUpdate(updateGuard) {\n  if (!getCurrentInstance()) {\n    warn(\"getCurrentInstance() returned null. onBeforeRouteUpdate() must be called at the top of a setup function\");\n    return;\n  }\n  const activeRecord = inject(\n    matchedRouteKey,\n    {}\n  ).value;\n  if (!activeRecord) {\n    warn(\"No active route record was found when calling `onBeforeRouteUpdate()`. Make sure you call this function inside a component child of <router-view>. Maybe you called it inside of App.vue?\");\n    return;\n  }\n  registerGuard(activeRecord, \"updateGuards\", updateGuard);\n}\nfunction guardToPromiseFn(guard, to, from, record, name) {\n  const enterCallbackArray = record && (record.enterCallbacks[name] = record.enterCallbacks[name] || []);\n  return () => new Promise((resolve, reject) => {\n    const next = (valid) => {\n      if (valid === false) {\n        reject(createRouterError(4, {\n          from,\n          to\n        }));\n      } else if (valid instanceof Error) {\n        reject(valid);\n      } else if (isRouteLocation(valid)) {\n        reject(createRouterError(2, {\n          from: to,\n          to: valid\n        }));\n      } else {\n        if (enterCallbackArray && record.enterCallbacks[name] === enterCallbackArray && typeof valid === \"function\") {\n          enterCallbackArray.push(valid);\n        }\n        resolve();\n      }\n    };\n    const guardReturn = guard.call(record && record.instances[name], to, from, true ? canOnlyBeCalledOnce(next, to, from) : next);\n    let guardCall = Promise.resolve(guardReturn);\n    if (guard.length < 3)\n      guardCall = guardCall.then(next);\n    if (guard.length > 2) {\n      const message = `The \"next\" callback was never called inside of ${guard.name ? '\"' + guard.name + '\"' : \"\"}:\n${guard.toString()}\n. If you are returning a value instead of calling \"next\", make sure to remove the \"next\" parameter from your function.`;\n      if (typeof guardReturn === \"object\" && \"then\" in guardReturn) {\n        guardCall = guardCall.then((resolvedValue) => {\n          if (!next._called) {\n            warn(message);\n            return Promise.reject(new Error(\"Invalid navigation guard\"));\n          }\n          return resolvedValue;\n        });\n      } else if (guardReturn !== void 0) {\n        if (!next._called) {\n          warn(message);\n          reject(new Error(\"Invalid navigation guard\"));\n          return;\n        }\n      }\n    }\n    guardCall.catch((err) => reject(err));\n  });\n}\nfunction canOnlyBeCalledOnce(next, to, from) {\n  let called = 0;\n  return function() {\n    if (called++ === 1)\n      warn(`The \"next\" callback was called more than once in one navigation guard when going from \"${from.fullPath}\" to \"${to.fullPath}\". It should be called exactly one time in each navigation guard. This will fail in production.`);\n    next._called = true;\n    if (called === 1)\n      next.apply(null, arguments);\n  };\n}\nfunction extractComponentsGuards(matched, guardType, to, from) {\n  const guards = [];\n  for (const record of matched) {\n    if (!record.components && !record.children.length) {\n      warn(`Record with path \"${record.path}\" is either missing a \"component(s)\" or \"children\" property.`);\n    }\n    for (const name in record.components) {\n      let rawComponent = record.components[name];\n      if (true) {\n        if (!rawComponent || typeof rawComponent !== \"object\" && typeof rawComponent !== \"function\") {\n          warn(`Component \"${name}\" in record with path \"${record.path}\" is not a valid component. Received \"${String(rawComponent)}\".`);\n          throw new Error(\"Invalid route component\");\n        } else if (\"then\" in rawComponent) {\n          warn(`Component \"${name}\" in record with path \"${record.path}\" is a Promise instead of a function that returns a Promise. Did you write \"import('./MyPage.vue')\" instead of \"() => import('./MyPage.vue')\" ? This will break in production if not fixed.`);\n          const promise = rawComponent;\n          rawComponent = () => promise;\n        } else if (rawComponent.__asyncLoader && !rawComponent.__warnedDefineAsync) {\n          rawComponent.__warnedDefineAsync = true;\n          warn(`Component \"${name}\" in record with path \"${record.path}\" is defined using \"defineAsyncComponent()\". Write \"() => import('./MyPage.vue')\" instead of \"defineAsyncComponent(() => import('./MyPage.vue'))\".`);\n        }\n      }\n      if (guardType !== \"beforeRouteEnter\" && !record.instances[name])\n        continue;\n      if (isRouteComponent(rawComponent)) {\n        const options = rawComponent.__vccOpts || rawComponent;\n        const guard = options[guardType];\n        guard && guards.push(guardToPromiseFn(guard, to, from, record, name));\n      } else {\n        let componentPromise = rawComponent();\n        if (!(\"catch\" in componentPromise)) {\n          warn(`Component \"${name}\" in record with path \"${record.path}\" is a function that does not return a Promise. If you were passing a functional component, make sure to add a \"displayName\" to the component. This will break in production if not fixed.`);\n          componentPromise = Promise.resolve(componentPromise);\n        }\n        guards.push(() => componentPromise.then((resolved) => {\n          if (!resolved)\n            return Promise.reject(new Error(`Couldn't resolve component \"${name}\" at \"${record.path}\"`));\n          const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;\n          record.components[name] = resolvedComponent;\n          const options = resolvedComponent.__vccOpts || resolvedComponent;\n          const guard = options[guardType];\n          return guard && guardToPromiseFn(guard, to, from, record, name)();\n        }));\n      }\n    }\n  }\n  return guards;\n}\nfunction isRouteComponent(component) {\n  return typeof component === \"object\" || \"displayName\" in component || \"props\" in component || \"__vccOpts\" in component;\n}\nfunction loadRouteLocation(route) {\n  return route.matched.every((record) => record.redirect) ? Promise.reject(new Error(\"Cannot load a route that redirects.\")) : Promise.all(route.matched.map((record) => record.components && Promise.all(Object.keys(record.components).reduce((promises, name) => {\n    const rawComponent = record.components[name];\n    if (typeof rawComponent === \"function\" && !(\"displayName\" in rawComponent)) {\n      promises.push(rawComponent().then((resolved) => {\n        if (!resolved)\n          return Promise.reject(new Error(`Couldn't resolve component \"${name}\" at \"${record.path}\". Ensure you passed a function that returns a promise.`));\n        const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;\n        record.components[name] = resolvedComponent;\n        return;\n      }));\n    }\n    return promises;\n  }, [])))).then(() => route);\n}\nfunction useLink(props) {\n  const router = inject(routerKey);\n  const currentRoute = inject(routeLocationKey);\n  const route = computed(() => router.resolve(unref(props.to)));\n  const activeRecordIndex = computed(() => {\n    const { matched } = route.value;\n    const { length } = matched;\n    const routeMatched = matched[length - 1];\n    const currentMatched = currentRoute.matched;\n    if (!routeMatched || !currentMatched.length)\n      return -1;\n    const index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));\n    if (index > -1)\n      return index;\n    const parentRecordPath = getOriginalPath(matched[length - 2]);\n    return length > 1 && getOriginalPath(routeMatched) === parentRecordPath && currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index;\n  });\n  const isActive = computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));\n  const isExactActive = computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));\n  function navigate(e = {}) {\n    if (guardEvent(e)) {\n      return router[unref(props.replace) ? \"replace\" : \"push\"](\n        unref(props.to)\n      ).catch(noop);\n    }\n    return Promise.resolve();\n  }\n  if (isBrowser) {\n    const instance = getCurrentInstance();\n    if (instance) {\n      const linkContextDevtools = {\n        route: route.value,\n        isActive: isActive.value,\n        isExactActive: isExactActive.value\n      };\n      instance.__vrl_devtools = instance.__vrl_devtools || [];\n      instance.__vrl_devtools.push(linkContextDevtools);\n      watchEffect(() => {\n        linkContextDevtools.route = route.value;\n        linkContextDevtools.isActive = isActive.value;\n        linkContextDevtools.isExactActive = isExactActive.value;\n      }, { flush: \"post\" });\n    }\n  }\n  return {\n    route,\n    href: computed(() => route.value.href),\n    isActive,\n    isExactActive,\n    navigate\n  };\n}\nvar RouterLinkImpl = defineComponent({\n  name: \"RouterLink\",\n  compatConfig: { MODE: 3 },\n  props: {\n    to: {\n      type: [String, Object],\n      required: true\n    },\n    replace: Boolean,\n    activeClass: String,\n    exactActiveClass: String,\n    custom: Boolean,\n    ariaCurrentValue: {\n      type: String,\n      default: \"page\"\n    }\n  },\n  useLink,\n  setup(props, { slots }) {\n    const link = reactive(useLink(props));\n    const { options } = inject(routerKey);\n    const elClass = computed(() => ({\n      [getLinkClass(props.activeClass, options.linkActiveClass, \"router-link-active\")]: link.isActive,\n      [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, \"router-link-exact-active\")]: link.isExactActive\n    }));\n    return () => {\n      const children = slots.default && slots.default(link);\n      return props.custom ? children : h(\"a\", {\n        \"aria-current\": link.isExactActive ? props.ariaCurrentValue : null,\n        href: link.href,\n        onClick: link.navigate,\n        class: elClass.value\n      }, children);\n    };\n  }\n});\nvar RouterLink = RouterLinkImpl;\nfunction guardEvent(e) {\n  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)\n    return;\n  if (e.defaultPrevented)\n    return;\n  if (e.button !== void 0 && e.button !== 0)\n    return;\n  if (e.currentTarget && e.currentTarget.getAttribute) {\n    const target = e.currentTarget.getAttribute(\"target\");\n    if (/\\b_blank\\b/i.test(target))\n      return;\n  }\n  if (e.preventDefault)\n    e.preventDefault();\n  return true;\n}\nfunction includesParams(outer, inner) {\n  for (const key in inner) {\n    const innerValue = inner[key];\n    const outerValue = outer[key];\n    if (typeof innerValue === \"string\") {\n      if (innerValue !== outerValue)\n        return false;\n    } else {\n      if (!isArray(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i) => value !== outerValue[i]))\n        return false;\n    }\n  }\n  return true;\n}\nfunction getOriginalPath(record) {\n  return record ? record.aliasOf ? record.aliasOf.path : record.path : \"\";\n}\nvar getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;\nvar RouterViewImpl = defineComponent({\n  name: \"RouterView\",\n  inheritAttrs: false,\n  props: {\n    name: {\n      type: String,\n      default: \"default\"\n    },\n    route: Object\n  },\n  compatConfig: { MODE: 3 },\n  setup(props, { attrs, slots }) {\n    warnDeprecatedUsage();\n    const injectedRoute = inject(routerViewLocationKey);\n    const routeToDisplay = computed(() => props.route || injectedRoute.value);\n    const injectedDepth = inject(viewDepthKey, 0);\n    const depth = computed(() => {\n      let initialDepth = unref(injectedDepth);\n      const { matched } = routeToDisplay.value;\n      let matchedRoute;\n      while ((matchedRoute = matched[initialDepth]) && !matchedRoute.components) {\n        initialDepth++;\n      }\n      return initialDepth;\n    });\n    const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth.value]);\n    provide(viewDepthKey, computed(() => depth.value + 1));\n    provide(matchedRouteKey, matchedRouteRef);\n    provide(routerViewLocationKey, routeToDisplay);\n    const viewRef = ref();\n    watch(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to, name], [oldInstance, from, oldName]) => {\n      if (to) {\n        to.instances[name] = instance;\n        if (from && from !== to && instance && instance === oldInstance) {\n          if (!to.leaveGuards.size) {\n            to.leaveGuards = from.leaveGuards;\n          }\n          if (!to.updateGuards.size) {\n            to.updateGuards = from.updateGuards;\n          }\n        }\n      }\n      if (instance && to && (!from || !isSameRouteRecord(to, from) || !oldInstance)) {\n        (to.enterCallbacks[name] || []).forEach((callback) => callback(instance));\n      }\n    }, { flush: \"post\" });\n    return () => {\n      const route = routeToDisplay.value;\n      const currentName = props.name;\n      const matchedRoute = matchedRouteRef.value;\n      const ViewComponent = matchedRoute && matchedRoute.components[currentName];\n      if (!ViewComponent) {\n        return normalizeSlot(slots.default, { Component: ViewComponent, route });\n      }\n      const routePropsOption = matchedRoute.props[currentName];\n      const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === \"function\" ? routePropsOption(route) : routePropsOption : null;\n      const onVnodeUnmounted = (vnode) => {\n        if (vnode.component.isUnmounted) {\n          matchedRoute.instances[currentName] = null;\n        }\n      };\n      const component = h(ViewComponent, assign({}, routeProps, attrs, {\n        onVnodeUnmounted,\n        ref: viewRef\n      }));\n      if (isBrowser && component.ref) {\n        const info = {\n          depth: depth.value,\n          name: matchedRoute.name,\n          path: matchedRoute.path,\n          meta: matchedRoute.meta\n        };\n        const internalInstances = isArray(component.ref) ? component.ref.map((r) => r.i) : [component.ref.i];\n        internalInstances.forEach((instance) => {\n          instance.__vrv_devtools = info;\n        });\n      }\n      return normalizeSlot(slots.default, { Component: component, route }) || component;\n    };\n  }\n});\nfunction normalizeSlot(slot, data) {\n  if (!slot)\n    return null;\n  const slotContent = slot(data);\n  return slotContent.length === 1 ? slotContent[0] : slotContent;\n}\nvar RouterView = RouterViewImpl;\nfunction warnDeprecatedUsage() {\n  const instance = getCurrentInstance();\n  const parentName = instance.parent && instance.parent.type.name;\n  if (parentName && (parentName === \"KeepAlive\" || parentName.includes(\"Transition\"))) {\n    const comp = parentName === \"KeepAlive\" ? \"keep-alive\" : \"transition\";\n    warn(`<router-view> can no longer be used directly inside <transition> or <keep-alive>.\nUse slot props instead:\n\n<router-view v-slot=\"{ Component }\">\n  <${comp}>\n    <component :is=\"Component\" />\n  </${comp}>\n</router-view>`);\n  }\n}\nfunction formatRouteLocation(routeLocation, tooltip) {\n  const copy = assign({}, routeLocation, {\n    matched: routeLocation.matched.map((matched) => omit(matched, [\"instances\", \"children\", \"aliasOf\"]))\n  });\n  return {\n    _custom: {\n      type: null,\n      readOnly: true,\n      display: routeLocation.fullPath,\n      tooltip,\n      value: copy\n    }\n  };\n}\nfunction formatDisplay(display) {\n  return {\n    _custom: {\n      display\n    }\n  };\n}\nvar routerId = 0;\nfunction addDevtools(app, router, matcher) {\n  if (router.__hasDevtools)\n    return;\n  router.__hasDevtools = true;\n  const id = routerId++;\n  setupDevtoolsPlugin({\n    id: \"org.vuejs.router\" + (id ? \".\" + id : \"\"),\n    label: \"Vue Router\",\n    packageName: \"vue-router\",\n    homepage: \"https://router.vuejs.org\",\n    logo: \"https://router.vuejs.org/logo.png\",\n    componentStateTypes: [\"Routing\"],\n    app\n  }, (api) => {\n    if (typeof api.now !== \"function\") {\n      console.warn(\"[Vue Router]: You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.\");\n    }\n    api.on.inspectComponent((payload, ctx) => {\n      if (payload.instanceData) {\n        payload.instanceData.state.push({\n          type: \"Routing\",\n          key: \"$route\",\n          editable: false,\n          value: formatRouteLocation(router.currentRoute.value, \"Current Route\")\n        });\n      }\n    });\n    api.on.visitComponentTree(({ treeNode: node, componentInstance }) => {\n      if (componentInstance.__vrv_devtools) {\n        const info = componentInstance.__vrv_devtools;\n        node.tags.push({\n          label: (info.name ? `${info.name.toString()}: ` : \"\") + info.path,\n          textColor: 0,\n          tooltip: \"This component is rendered by &lt;router-view&gt;\",\n          backgroundColor: PINK_500\n        });\n      }\n      if (isArray(componentInstance.__vrl_devtools)) {\n        componentInstance.__devtoolsApi = api;\n        componentInstance.__vrl_devtools.forEach((devtoolsData) => {\n          let backgroundColor = ORANGE_400;\n          let tooltip = \"\";\n          if (devtoolsData.isExactActive) {\n            backgroundColor = LIME_500;\n            tooltip = \"This is exactly active\";\n          } else if (devtoolsData.isActive) {\n            backgroundColor = BLUE_600;\n            tooltip = \"This link is active\";\n          }\n          node.tags.push({\n            label: devtoolsData.route.path,\n            textColor: 0,\n            tooltip,\n            backgroundColor\n          });\n        });\n      }\n    });\n    watch(router.currentRoute, () => {\n      refreshRoutesView();\n      api.notifyComponentUpdate();\n      api.sendInspectorTree(routerInspectorId);\n      api.sendInspectorState(routerInspectorId);\n    });\n    const navigationsLayerId = \"router:navigations:\" + id;\n    api.addTimelineLayer({\n      id: navigationsLayerId,\n      label: `Router${id ? \" \" + id : \"\"} Navigations`,\n      color: 4237508\n    });\n    router.onError((error, to) => {\n      api.addTimelineEvent({\n        layerId: navigationsLayerId,\n        event: {\n          title: \"Error during Navigation\",\n          subtitle: to.fullPath,\n          logType: \"error\",\n          time: api.now(),\n          data: { error },\n          groupId: to.meta.__navigationId\n        }\n      });\n    });\n    let navigationId = 0;\n    router.beforeEach((to, from) => {\n      const data = {\n        guard: formatDisplay(\"beforeEach\"),\n        from: formatRouteLocation(from, \"Current Location during this navigation\"),\n        to: formatRouteLocation(to, \"Target location\")\n      };\n      Object.defineProperty(to.meta, \"__navigationId\", {\n        value: navigationId++\n      });\n      api.addTimelineEvent({\n        layerId: navigationsLayerId,\n        event: {\n          time: api.now(),\n          title: \"Start of navigation\",\n          subtitle: to.fullPath,\n          data,\n          groupId: to.meta.__navigationId\n        }\n      });\n    });\n    router.afterEach((to, from, failure) => {\n      const data = {\n        guard: formatDisplay(\"afterEach\")\n      };\n      if (failure) {\n        data.failure = {\n          _custom: {\n            type: Error,\n            readOnly: true,\n            display: failure ? failure.message : \"\",\n            tooltip: \"Navigation Failure\",\n            value: failure\n          }\n        };\n        data.status = formatDisplay(\"\\u274C\");\n      } else {\n        data.status = formatDisplay(\"\\u2705\");\n      }\n      data.from = formatRouteLocation(from, \"Current Location during this navigation\");\n      data.to = formatRouteLocation(to, \"Target location\");\n      api.addTimelineEvent({\n        layerId: navigationsLayerId,\n        event: {\n          title: \"End of navigation\",\n          subtitle: to.fullPath,\n          time: api.now(),\n          data,\n          logType: failure ? \"warning\" : \"default\",\n          groupId: to.meta.__navigationId\n        }\n      });\n    });\n    const routerInspectorId = \"router-inspector:\" + id;\n    api.addInspector({\n      id: routerInspectorId,\n      label: \"Routes\" + (id ? \" \" + id : \"\"),\n      icon: \"book\",\n      treeFilterPlaceholder: \"Search routes\"\n    });\n    function refreshRoutesView() {\n      if (!activeRoutesPayload)\n        return;\n      const payload = activeRoutesPayload;\n      let routes = matcher.getRoutes().filter((route) => !route.parent);\n      routes.forEach(resetMatchStateOnRouteRecord);\n      if (payload.filter) {\n        routes = routes.filter((route) => isRouteMatching(route, payload.filter.toLowerCase()));\n      }\n      routes.forEach((route) => markRouteRecordActive(route, router.currentRoute.value));\n      payload.rootNodes = routes.map(formatRouteRecordForInspector);\n    }\n    let activeRoutesPayload;\n    api.on.getInspectorTree((payload) => {\n      activeRoutesPayload = payload;\n      if (payload.app === app && payload.inspectorId === routerInspectorId) {\n        refreshRoutesView();\n      }\n    });\n    api.on.getInspectorState((payload) => {\n      if (payload.app === app && payload.inspectorId === routerInspectorId) {\n        const routes = matcher.getRoutes();\n        const route = routes.find((route2) => route2.record.__vd_id === payload.nodeId);\n        if (route) {\n          payload.state = {\n            options: formatRouteRecordMatcherForStateInspector(route)\n          };\n        }\n      }\n    });\n    api.sendInspectorTree(routerInspectorId);\n    api.sendInspectorState(routerInspectorId);\n  });\n}\nfunction modifierForKey(key) {\n  if (key.optional) {\n    return key.repeatable ? \"*\" : \"?\";\n  } else {\n    return key.repeatable ? \"+\" : \"\";\n  }\n}\nfunction formatRouteRecordMatcherForStateInspector(route) {\n  const { record } = route;\n  const fields = [\n    { editable: false, key: \"path\", value: record.path }\n  ];\n  if (record.name != null) {\n    fields.push({\n      editable: false,\n      key: \"name\",\n      value: record.name\n    });\n  }\n  fields.push({ editable: false, key: \"regexp\", value: route.re });\n  if (route.keys.length) {\n    fields.push({\n      editable: false,\n      key: \"keys\",\n      value: {\n        _custom: {\n          type: null,\n          readOnly: true,\n          display: route.keys.map((key) => `${key.name}${modifierForKey(key)}`).join(\" \"),\n          tooltip: \"Param keys\",\n          value: route.keys\n        }\n      }\n    });\n  }\n  if (record.redirect != null) {\n    fields.push({\n      editable: false,\n      key: \"redirect\",\n      value: record.redirect\n    });\n  }\n  if (route.alias.length) {\n    fields.push({\n      editable: false,\n      key: \"aliases\",\n      value: route.alias.map((alias) => alias.record.path)\n    });\n  }\n  if (Object.keys(route.record.meta).length) {\n    fields.push({\n      editable: false,\n      key: \"meta\",\n      value: route.record.meta\n    });\n  }\n  fields.push({\n    key: \"score\",\n    editable: false,\n    value: {\n      _custom: {\n        type: null,\n        readOnly: true,\n        display: route.score.map((score) => score.join(\", \")).join(\" | \"),\n        tooltip: \"Score used to sort routes\",\n        value: route.score\n      }\n    }\n  });\n  return fields;\n}\nvar PINK_500 = 15485081;\nvar BLUE_600 = 2450411;\nvar LIME_500 = 8702998;\nvar CYAN_400 = 2282478;\nvar ORANGE_400 = 16486972;\nvar DARK = 6710886;\nfunction formatRouteRecordForInspector(route) {\n  const tags = [];\n  const { record } = route;\n  if (record.name != null) {\n    tags.push({\n      label: String(record.name),\n      textColor: 0,\n      backgroundColor: CYAN_400\n    });\n  }\n  if (record.aliasOf) {\n    tags.push({\n      label: \"alias\",\n      textColor: 0,\n      backgroundColor: ORANGE_400\n    });\n  }\n  if (route.__vd_match) {\n    tags.push({\n      label: \"matches\",\n      textColor: 0,\n      backgroundColor: PINK_500\n    });\n  }\n  if (route.__vd_exactActive) {\n    tags.push({\n      label: \"exact\",\n      textColor: 0,\n      backgroundColor: LIME_500\n    });\n  }\n  if (route.__vd_active) {\n    tags.push({\n      label: \"active\",\n      textColor: 0,\n      backgroundColor: BLUE_600\n    });\n  }\n  if (record.redirect) {\n    tags.push({\n      label: typeof record.redirect === \"string\" ? `redirect: ${record.redirect}` : \"redirects\",\n      textColor: 16777215,\n      backgroundColor: DARK\n    });\n  }\n  let id = record.__vd_id;\n  if (id == null) {\n    id = String(routeRecordId++);\n    record.__vd_id = id;\n  }\n  return {\n    id,\n    label: record.path,\n    tags,\n    children: route.children.map(formatRouteRecordForInspector)\n  };\n}\nvar routeRecordId = 0;\nvar EXTRACT_REGEXP_RE = /^\\/(.*)\\/([a-z]*)$/;\nfunction markRouteRecordActive(route, currentRoute) {\n  const isExactActive = currentRoute.matched.length && isSameRouteRecord(currentRoute.matched[currentRoute.matched.length - 1], route.record);\n  route.__vd_exactActive = route.__vd_active = isExactActive;\n  if (!isExactActive) {\n    route.__vd_active = currentRoute.matched.some((match) => isSameRouteRecord(match, route.record));\n  }\n  route.children.forEach((childRoute) => markRouteRecordActive(childRoute, currentRoute));\n}\nfunction resetMatchStateOnRouteRecord(route) {\n  route.__vd_match = false;\n  route.children.forEach(resetMatchStateOnRouteRecord);\n}\nfunction isRouteMatching(route, filter) {\n  const found = String(route.re).match(EXTRACT_REGEXP_RE);\n  route.__vd_match = false;\n  if (!found || found.length < 3) {\n    return false;\n  }\n  const nonEndingRE = new RegExp(found[1].replace(/\\$$/, \"\"), found[2]);\n  if (nonEndingRE.test(filter)) {\n    route.children.forEach((child) => isRouteMatching(child, filter));\n    if (route.record.path !== \"/\" || filter === \"/\") {\n      route.__vd_match = route.re.test(filter);\n      return true;\n    }\n    return false;\n  }\n  const path = route.record.path.toLowerCase();\n  const decodedPath = decode(path);\n  if (!filter.startsWith(\"/\") && (decodedPath.includes(filter) || path.includes(filter)))\n    return true;\n  if (decodedPath.startsWith(filter) || path.startsWith(filter))\n    return true;\n  if (route.record.name && String(route.record.name).includes(filter))\n    return true;\n  return route.children.some((child) => isRouteMatching(child, filter));\n}\nfunction omit(obj, keys) {\n  const ret = {};\n  for (const key in obj) {\n    if (!keys.includes(key)) {\n      ret[key] = obj[key];\n    }\n  }\n  return ret;\n}\nfunction createRouter(options) {\n  const matcher = createRouterMatcher(options.routes, options);\n  const parseQuery$1 = options.parseQuery || parseQuery;\n  const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;\n  const routerHistory = options.history;\n  if (!routerHistory)\n    throw new Error('Provide the \"history\" option when calling \"createRouter()\": https://next.router.vuejs.org/api/#history.');\n  const beforeGuards = useCallbacks();\n  const beforeResolveGuards = useCallbacks();\n  const afterGuards = useCallbacks();\n  const currentRoute = shallowRef(START_LOCATION_NORMALIZED);\n  let pendingLocation = START_LOCATION_NORMALIZED;\n  if (isBrowser && options.scrollBehavior && \"scrollRestoration\" in history) {\n    history.scrollRestoration = \"manual\";\n  }\n  const normalizeParams = applyToParams.bind(null, (paramValue) => \"\" + paramValue);\n  const encodeParams = applyToParams.bind(null, encodeParam);\n  const decodeParams = applyToParams.bind(null, decode);\n  function addRoute(parentOrRoute, route) {\n    let parent;\n    let record;\n    if (isRouteName(parentOrRoute)) {\n      parent = matcher.getRecordMatcher(parentOrRoute);\n      record = route;\n    } else {\n      record = parentOrRoute;\n    }\n    return matcher.addRoute(record, parent);\n  }\n  function removeRoute(name) {\n    const recordMatcher = matcher.getRecordMatcher(name);\n    if (recordMatcher) {\n      matcher.removeRoute(recordMatcher);\n    } else if (true) {\n      warn(`Cannot remove non-existent route \"${String(name)}\"`);\n    }\n  }\n  function getRoutes() {\n    return matcher.getRoutes().map((routeMatcher) => routeMatcher.record);\n  }\n  function hasRoute(name) {\n    return !!matcher.getRecordMatcher(name);\n  }\n  function resolve(rawLocation, currentLocation) {\n    currentLocation = assign({}, currentLocation || currentRoute.value);\n    if (typeof rawLocation === \"string\") {\n      const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);\n      const matchedRoute2 = matcher.resolve({ path: locationNormalized.path }, currentLocation);\n      const href2 = routerHistory.createHref(locationNormalized.fullPath);\n      if (true) {\n        if (href2.startsWith(\"//\"))\n          warn(`Location \"${rawLocation}\" resolved to \"${href2}\". A resolved location cannot start with multiple slashes.`);\n        else if (!matchedRoute2.matched.length) {\n          warn(`No match found for location with path \"${rawLocation}\"`);\n        }\n      }\n      return assign(locationNormalized, matchedRoute2, {\n        params: decodeParams(matchedRoute2.params),\n        hash: decode(locationNormalized.hash),\n        redirectedFrom: void 0,\n        href: href2\n      });\n    }\n    let matcherLocation;\n    if (\"path\" in rawLocation) {\n      if (\"params\" in rawLocation && !(\"name\" in rawLocation) && Object.keys(rawLocation.params).length) {\n        warn(`Path \"${rawLocation.path}\" was passed with params but they will be ignored. Use a named route alongside params instead.`);\n      }\n      matcherLocation = assign({}, rawLocation, {\n        path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path\n      });\n    } else {\n      const targetParams = assign({}, rawLocation.params);\n      for (const key in targetParams) {\n        if (targetParams[key] == null) {\n          delete targetParams[key];\n        }\n      }\n      matcherLocation = assign({}, rawLocation, {\n        params: encodeParams(rawLocation.params)\n      });\n      currentLocation.params = encodeParams(currentLocation.params);\n    }\n    const matchedRoute = matcher.resolve(matcherLocation, currentLocation);\n    const hash = rawLocation.hash || \"\";\n    if (hash && !hash.startsWith(\"#\")) {\n      warn(`A \\`hash\\` should always start with the character \"#\". Replace \"${hash}\" with \"#${hash}\".`);\n    }\n    matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));\n    const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {\n      hash: encodeHash(hash),\n      path: matchedRoute.path\n    }));\n    const href = routerHistory.createHref(fullPath);\n    if (true) {\n      if (href.startsWith(\"//\")) {\n        warn(`Location \"${rawLocation}\" resolved to \"${href}\". A resolved location cannot start with multiple slashes.`);\n      } else if (!matchedRoute.matched.length) {\n        warn(`No match found for location with path \"${\"path\" in rawLocation ? rawLocation.path : rawLocation}\"`);\n      }\n    }\n    return assign({\n      fullPath,\n      hash,\n      query: stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}\n    }, matchedRoute, {\n      redirectedFrom: void 0,\n      href\n    });\n  }\n  function locationAsObject(to) {\n    return typeof to === \"string\" ? parseURL(parseQuery$1, to, currentRoute.value.path) : assign({}, to);\n  }\n  function checkCanceledNavigation(to, from) {\n    if (pendingLocation !== to) {\n      return createRouterError(8, {\n        from,\n        to\n      });\n    }\n  }\n  function push(to) {\n    return pushWithRedirect(to);\n  }\n  function replace(to) {\n    return push(assign(locationAsObject(to), { replace: true }));\n  }\n  function handleRedirectRecord(to) {\n    const lastMatched = to.matched[to.matched.length - 1];\n    if (lastMatched && lastMatched.redirect) {\n      const { redirect } = lastMatched;\n      let newTargetLocation = typeof redirect === \"function\" ? redirect(to) : redirect;\n      if (typeof newTargetLocation === \"string\") {\n        newTargetLocation = newTargetLocation.includes(\"?\") || newTargetLocation.includes(\"#\") ? newTargetLocation = locationAsObject(newTargetLocation) : { path: newTargetLocation };\n        newTargetLocation.params = {};\n      }\n      if (!(\"path\" in newTargetLocation) && !(\"name\" in newTargetLocation)) {\n        warn(`Invalid redirect found:\n${JSON.stringify(newTargetLocation, null, 2)}\n when navigating to \"${to.fullPath}\". A redirect must contain a name or path. This will break in production.`);\n        throw new Error(\"Invalid redirect\");\n      }\n      return assign({\n        query: to.query,\n        hash: to.hash,\n        params: \"path\" in newTargetLocation ? {} : to.params\n      }, newTargetLocation);\n    }\n  }\n  function pushWithRedirect(to, redirectedFrom) {\n    const targetLocation = pendingLocation = resolve(to);\n    const from = currentRoute.value;\n    const data = to.state;\n    const force = to.force;\n    const replace2 = to.replace === true;\n    const shouldRedirect = handleRedirectRecord(targetLocation);\n    if (shouldRedirect)\n      return pushWithRedirect(\n        assign(locationAsObject(shouldRedirect), {\n          state: typeof shouldRedirect === \"object\" ? assign({}, data, shouldRedirect.state) : data,\n          force,\n          replace: replace2\n        }),\n        redirectedFrom || targetLocation\n      );\n    const toLocation = targetLocation;\n    toLocation.redirectedFrom = redirectedFrom;\n    let failure;\n    if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {\n      failure = createRouterError(16, { to: toLocation, from });\n      handleScroll(\n        from,\n        from,\n        true,\n        false\n      );\n    }\n    return (failure ? Promise.resolve(failure) : navigate(toLocation, from)).catch((error) => isNavigationFailure(error) ? isNavigationFailure(error, 2) ? error : markAsReady(error) : triggerError(error, toLocation, from)).then((failure2) => {\n      if (failure2) {\n        if (isNavigationFailure(failure2, 2)) {\n          if (isSameRouteLocation(stringifyQuery$1, resolve(failure2.to), toLocation) && redirectedFrom && (redirectedFrom._count = redirectedFrom._count ? redirectedFrom._count + 1 : 1) > 10) {\n            warn(`Detected an infinite redirection in a navigation guard when going from \"${from.fullPath}\" to \"${toLocation.fullPath}\". Aborting to avoid a Stack Overflow. This will break in production if not fixed.`);\n            return Promise.reject(new Error(\"Infinite redirect in navigation guard\"));\n          }\n          return pushWithRedirect(\n            assign({\n              replace: replace2\n            }, locationAsObject(failure2.to), {\n              state: typeof failure2.to === \"object\" ? assign({}, data, failure2.to.state) : data,\n              force\n            }),\n            redirectedFrom || toLocation\n          );\n        }\n      } else {\n        failure2 = finalizeNavigation(toLocation, from, true, replace2, data);\n      }\n      triggerAfterEach(toLocation, from, failure2);\n      return failure2;\n    });\n  }\n  function checkCanceledNavigationAndReject(to, from) {\n    const error = checkCanceledNavigation(to, from);\n    return error ? Promise.reject(error) : Promise.resolve();\n  }\n  function navigate(to, from) {\n    let guards;\n    const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);\n    guards = extractComponentsGuards(leavingRecords.reverse(), \"beforeRouteLeave\", to, from);\n    for (const record of leavingRecords) {\n      record.leaveGuards.forEach((guard) => {\n        guards.push(guardToPromiseFn(guard, to, from));\n      });\n    }\n    const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);\n    guards.push(canceledNavigationCheck);\n    return runGuardQueue(guards).then(() => {\n      guards = [];\n      for (const guard of beforeGuards.list()) {\n        guards.push(guardToPromiseFn(guard, to, from));\n      }\n      guards.push(canceledNavigationCheck);\n      return runGuardQueue(guards);\n    }).then(() => {\n      guards = extractComponentsGuards(updatingRecords, \"beforeRouteUpdate\", to, from);\n      for (const record of updatingRecords) {\n        record.updateGuards.forEach((guard) => {\n          guards.push(guardToPromiseFn(guard, to, from));\n        });\n      }\n      guards.push(canceledNavigationCheck);\n      return runGuardQueue(guards);\n    }).then(() => {\n      guards = [];\n      for (const record of to.matched) {\n        if (record.beforeEnter && !from.matched.includes(record)) {\n          if (isArray(record.beforeEnter)) {\n            for (const beforeEnter of record.beforeEnter)\n              guards.push(guardToPromiseFn(beforeEnter, to, from));\n          } else {\n            guards.push(guardToPromiseFn(record.beforeEnter, to, from));\n          }\n        }\n      }\n      guards.push(canceledNavigationCheck);\n      return runGuardQueue(guards);\n    }).then(() => {\n      to.matched.forEach((record) => record.enterCallbacks = {});\n      guards = extractComponentsGuards(enteringRecords, \"beforeRouteEnter\", to, from);\n      guards.push(canceledNavigationCheck);\n      return runGuardQueue(guards);\n    }).then(() => {\n      guards = [];\n      for (const guard of beforeResolveGuards.list()) {\n        guards.push(guardToPromiseFn(guard, to, from));\n      }\n      guards.push(canceledNavigationCheck);\n      return runGuardQueue(guards);\n    }).catch((err) => isNavigationFailure(err, 8) ? err : Promise.reject(err));\n  }\n  function triggerAfterEach(to, from, failure) {\n    for (const guard of afterGuards.list())\n      guard(to, from, failure);\n  }\n  function finalizeNavigation(toLocation, from, isPush, replace2, data) {\n    const error = checkCanceledNavigation(toLocation, from);\n    if (error)\n      return error;\n    const isFirstNavigation = from === START_LOCATION_NORMALIZED;\n    const state = !isBrowser ? {} : history.state;\n    if (isPush) {\n      if (replace2 || isFirstNavigation)\n        routerHistory.replace(toLocation.fullPath, assign({\n          scroll: isFirstNavigation && state && state.scroll\n        }, data));\n      else\n        routerHistory.push(toLocation.fullPath, data);\n    }\n    currentRoute.value = toLocation;\n    handleScroll(toLocation, from, isPush, isFirstNavigation);\n    markAsReady();\n  }\n  let removeHistoryListener;\n  function setupListeners() {\n    if (removeHistoryListener)\n      return;\n    removeHistoryListener = routerHistory.listen((to, _from, info) => {\n      if (!router.listening)\n        return;\n      const toLocation = resolve(to);\n      const shouldRedirect = handleRedirectRecord(toLocation);\n      if (shouldRedirect) {\n        pushWithRedirect(assign(shouldRedirect, { replace: true }), toLocation).catch(noop);\n        return;\n      }\n      pendingLocation = toLocation;\n      const from = currentRoute.value;\n      if (isBrowser) {\n        saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());\n      }\n      navigate(toLocation, from).catch((error) => {\n        if (isNavigationFailure(error, 4 | 8)) {\n          return error;\n        }\n        if (isNavigationFailure(error, 2)) {\n          pushWithRedirect(\n            error.to,\n            toLocation\n          ).then((failure) => {\n            if (isNavigationFailure(failure, 4 | 16) && !info.delta && info.type === NavigationType.pop) {\n              routerHistory.go(-1, false);\n            }\n          }).catch(noop);\n          return Promise.reject();\n        }\n        if (info.delta) {\n          routerHistory.go(-info.delta, false);\n        }\n        return triggerError(error, toLocation, from);\n      }).then((failure) => {\n        failure = failure || finalizeNavigation(\n          toLocation,\n          from,\n          false\n        );\n        if (failure) {\n          if (info.delta && !isNavigationFailure(failure, 8)) {\n            routerHistory.go(-info.delta, false);\n          } else if (info.type === NavigationType.pop && isNavigationFailure(failure, 4 | 16)) {\n            routerHistory.go(-1, false);\n          }\n        }\n        triggerAfterEach(toLocation, from, failure);\n      }).catch(noop);\n    });\n  }\n  let readyHandlers = useCallbacks();\n  let errorHandlers = useCallbacks();\n  let ready;\n  function triggerError(error, to, from) {\n    markAsReady(error);\n    const list = errorHandlers.list();\n    if (list.length) {\n      list.forEach((handler) => handler(error, to, from));\n    } else {\n      if (true) {\n        warn(\"uncaught error during route navigation:\");\n      }\n      console.error(error);\n    }\n    return Promise.reject(error);\n  }\n  function isReady() {\n    if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)\n      return Promise.resolve();\n    return new Promise((resolve2, reject) => {\n      readyHandlers.add([resolve2, reject]);\n    });\n  }\n  function markAsReady(err) {\n    if (!ready) {\n      ready = !err;\n      setupListeners();\n      readyHandlers.list().forEach(([resolve2, reject]) => err ? reject(err) : resolve2());\n      readyHandlers.reset();\n    }\n    return err;\n  }\n  function handleScroll(to, from, isPush, isFirstNavigation) {\n    const { scrollBehavior } = options;\n    if (!isBrowser || !scrollBehavior)\n      return Promise.resolve();\n    const scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;\n    return nextTick().then(() => scrollBehavior(to, from, scrollPosition)).then((position) => position && scrollToPosition(position)).catch((err) => triggerError(err, to, from));\n  }\n  const go = (delta) => routerHistory.go(delta);\n  let started;\n  const installedApps = /* @__PURE__ */ new Set();\n  const router = {\n    currentRoute,\n    listening: true,\n    addRoute,\n    removeRoute,\n    hasRoute,\n    getRoutes,\n    resolve,\n    options,\n    push,\n    replace,\n    go,\n    back: () => go(-1),\n    forward: () => go(1),\n    beforeEach: beforeGuards.add,\n    beforeResolve: beforeResolveGuards.add,\n    afterEach: afterGuards.add,\n    onError: errorHandlers.add,\n    isReady,\n    install(app) {\n      const router2 = this;\n      app.component(\"RouterLink\", RouterLink);\n      app.component(\"RouterView\", RouterView);\n      app.config.globalProperties.$router = router2;\n      Object.defineProperty(app.config.globalProperties, \"$route\", {\n        enumerable: true,\n        get: () => unref(currentRoute)\n      });\n      if (isBrowser && !started && currentRoute.value === START_LOCATION_NORMALIZED) {\n        started = true;\n        push(routerHistory.location).catch((err) => {\n          if (true)\n            warn(\"Unexpected error when starting the router:\", err);\n        });\n      }\n      const reactiveRoute = {};\n      for (const key in START_LOCATION_NORMALIZED) {\n        reactiveRoute[key] = computed(() => currentRoute.value[key]);\n      }\n      app.provide(routerKey, router2);\n      app.provide(routeLocationKey, reactive(reactiveRoute));\n      app.provide(routerViewLocationKey, currentRoute);\n      const unmountApp = app.unmount;\n      installedApps.add(app);\n      app.unmount = function() {\n        installedApps.delete(app);\n        if (installedApps.size < 1) {\n          pendingLocation = START_LOCATION_NORMALIZED;\n          removeHistoryListener && removeHistoryListener();\n          removeHistoryListener = null;\n          currentRoute.value = START_LOCATION_NORMALIZED;\n          started = false;\n          ready = false;\n        }\n        unmountApp();\n      };\n      if (isBrowser) {\n        addDevtools(app, router2, matcher);\n      }\n    }\n  };\n  return router;\n}\nfunction runGuardQueue(guards) {\n  return guards.reduce((promise, guard) => promise.then(() => guard()), Promise.resolve());\n}\nfunction extractChangingRecords(to, from) {\n  const leavingRecords = [];\n  const updatingRecords = [];\n  const enteringRecords = [];\n  const len = Math.max(from.matched.length, to.matched.length);\n  for (let i = 0; i < len; i++) {\n    const recordFrom = from.matched[i];\n    if (recordFrom) {\n      if (to.matched.find((record) => isSameRouteRecord(record, recordFrom)))\n        updatingRecords.push(recordFrom);\n      else\n        leavingRecords.push(recordFrom);\n    }\n    const recordTo = to.matched[i];\n    if (recordTo) {\n      if (!from.matched.find((record) => isSameRouteRecord(record, recordTo))) {\n        enteringRecords.push(recordTo);\n      }\n    }\n  }\n  return [leavingRecords, updatingRecords, enteringRecords];\n}\nfunction useRouter() {\n  return inject(routerKey);\n}\nfunction useRoute() {\n  return inject(routeLocationKey);\n}\n\nexport {\n  createWebHistory,\n  createMemoryHistory,\n  createWebHashHistory,\n  START_LOCATION_NORMALIZED,\n  NavigationFailureType,\n  isNavigationFailure,\n  createRouterMatcher,\n  parseQuery,\n  stringifyQuery,\n  matchedRouteKey,\n  viewDepthKey,\n  routerKey,\n  routeLocationKey,\n  routerViewLocationKey,\n  onBeforeRouteLeave,\n  onBeforeRouteUpdate,\n  loadRouteLocation,\n  useLink,\n  RouterLink,\n  RouterView,\n  createRouter,\n  useRouter,\n  useRoute\n};\n/*!\n  * vue-router v4.1.5\n  * (c) 2022 Eduardo San Martin Morote\n  * @license MIT\n  */\n//# sourceMappingURL=chunk-L5H4ESUF.js.map\n","start":1663126497448,"end":1663126497546},{"name":"vite:import-analysis","result":"import {\n  computed,\n  defineComponent,\n  getCurrentInstance,\n  h,\n  inject,\n  nextTick,\n  onActivated,\n  onDeactivated,\n  onUnmounted,\n  provide,\n  reactive,\n  ref,\n  shallowRef,\n  unref,\n  watch,\n  watchEffect\n} from \"/node_modules/.vite/deps/chunk-IGCPF6BW.js?v=7d84460d\";\n\n// ../node_modules/.pnpm/@vue+devtools-api@6.1.4/node_modules/@vue/devtools-api/lib/esm/env.js\nfunction getDevtoolsGlobalHook() {\n  return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;\n}\nfunction getTarget() {\n  return typeof navigator !== \"undefined\" && typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {};\n}\nvar isProxyAvailable = typeof Proxy === \"function\";\n\n// ../node_modules/.pnpm/@vue+devtools-api@6.1.4/node_modules/@vue/devtools-api/lib/esm/const.js\nvar HOOK_SETUP = \"devtools-plugin:setup\";\nvar HOOK_PLUGIN_SETTINGS_SET = \"plugin:settings:set\";\n\n// ../node_modules/.pnpm/@vue+devtools-api@6.1.4/node_modules/@vue/devtools-api/lib/esm/time.js\nvar supported;\nvar perf;\nfunction isPerformanceSupported() {\n  var _a;\n  if (supported !== void 0) {\n    return supported;\n  }\n  if (typeof window !== \"undefined\" && window.performance) {\n    supported = true;\n    perf = window.performance;\n  } else if (typeof global !== \"undefined\" && ((_a = global.perf_hooks) === null || _a === void 0 ? void 0 : _a.performance)) {\n    supported = true;\n    perf = global.perf_hooks.performance;\n  } else {\n    supported = false;\n  }\n  return supported;\n}\nfunction now() {\n  return isPerformanceSupported() ? perf.now() : Date.now();\n}\n\n// ../node_modules/.pnpm/@vue+devtools-api@6.1.4/node_modules/@vue/devtools-api/lib/esm/proxy.js\nvar ApiProxy = class {\n  constructor(plugin, hook) {\n    this.target = null;\n    this.targetQueue = [];\n    this.onQueue = [];\n    this.plugin = plugin;\n    this.hook = hook;\n    const defaultSettings = {};\n    if (plugin.settings) {\n      for (const id in plugin.settings) {\n        const item = plugin.settings[id];\n        defaultSettings[id] = item.defaultValue;\n      }\n    }\n    const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;\n    let currentSettings = Object.assign({}, defaultSettings);\n    try {\n      const raw = localStorage.getItem(localSettingsSaveId);\n      const data = JSON.parse(raw);\n      Object.assign(currentSettings, data);\n    } catch (e) {\n    }\n    this.fallbacks = {\n      getSettings() {\n        return currentSettings;\n      },\n      setSettings(value) {\n        try {\n          localStorage.setItem(localSettingsSaveId, JSON.stringify(value));\n        } catch (e) {\n        }\n        currentSettings = value;\n      },\n      now() {\n        return now();\n      }\n    };\n    if (hook) {\n      hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {\n        if (pluginId === this.plugin.id) {\n          this.fallbacks.setSettings(value);\n        }\n      });\n    }\n    this.proxiedOn = new Proxy({}, {\n      get: (_target, prop) => {\n        if (this.target) {\n          return this.target.on[prop];\n        } else {\n          return (...args) => {\n            this.onQueue.push({\n              method: prop,\n              args\n            });\n          };\n        }\n      }\n    });\n    this.proxiedTarget = new Proxy({}, {\n      get: (_target, prop) => {\n        if (this.target) {\n          return this.target[prop];\n        } else if (prop === \"on\") {\n          return this.proxiedOn;\n        } else if (Object.keys(this.fallbacks).includes(prop)) {\n          return (...args) => {\n            this.targetQueue.push({\n              method: prop,\n              args,\n              resolve: () => {\n              }\n            });\n            return this.fallbacks[prop](...args);\n          };\n        } else {\n          return (...args) => {\n            return new Promise((resolve) => {\n              this.targetQueue.push({\n                method: prop,\n                args,\n                resolve\n              });\n            });\n          };\n        }\n      }\n    });\n  }\n  async setRealTarget(target) {\n    this.target = target;\n    for (const item of this.onQueue) {\n      this.target.on[item.method](...item.args);\n    }\n    for (const item of this.targetQueue) {\n      item.resolve(await this.target[item.method](...item.args));\n    }\n  }\n};\n\n// ../node_modules/.pnpm/@vue+devtools-api@6.1.4/node_modules/@vue/devtools-api/lib/esm/index.js\nfunction setupDevtoolsPlugin(pluginDescriptor, setupFn) {\n  const descriptor = pluginDescriptor;\n  const target = getTarget();\n  const hook = getDevtoolsGlobalHook();\n  const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;\n  if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {\n    hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);\n  } else {\n    const proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;\n    const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];\n    list.push({\n      pluginDescriptor: descriptor,\n      setupFn,\n      proxy\n    });\n    if (proxy)\n      setupFn(proxy.proxiedTarget);\n  }\n}\n\n// ../node_modules/.pnpm/vue-router@4.1.5_vue@3.2.39/node_modules/vue-router/dist/vue-router.mjs\nvar isBrowser = typeof window !== \"undefined\";\nfunction isESModule(obj) {\n  return obj.__esModule || obj[Symbol.toStringTag] === \"Module\";\n}\nvar assign = Object.assign;\nfunction applyToParams(fn, params) {\n  const newParams = {};\n  for (const key in params) {\n    const value = params[key];\n    newParams[key] = isArray(value) ? value.map(fn) : fn(value);\n  }\n  return newParams;\n}\nvar noop = () => {\n};\nvar isArray = Array.isArray;\nfunction warn(msg) {\n  const args = Array.from(arguments).slice(1);\n  console.warn.apply(console, [\"[Vue Router warn]: \" + msg].concat(args));\n}\nvar TRAILING_SLASH_RE = /\\/$/;\nvar removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, \"\");\nfunction parseURL(parseQuery2, location2, currentLocation = \"/\") {\n  let path, query = {}, searchString = \"\", hash = \"\";\n  const hashPos = location2.indexOf(\"#\");\n  let searchPos = location2.indexOf(\"?\");\n  if (hashPos < searchPos && hashPos >= 0) {\n    searchPos = -1;\n  }\n  if (searchPos > -1) {\n    path = location2.slice(0, searchPos);\n    searchString = location2.slice(searchPos + 1, hashPos > -1 ? hashPos : location2.length);\n    query = parseQuery2(searchString);\n  }\n  if (hashPos > -1) {\n    path = path || location2.slice(0, hashPos);\n    hash = location2.slice(hashPos, location2.length);\n  }\n  path = resolveRelativePath(path != null ? path : location2, currentLocation);\n  return {\n    fullPath: path + (searchString && \"?\") + searchString + hash,\n    path,\n    query,\n    hash\n  };\n}\nfunction stringifyURL(stringifyQuery2, location2) {\n  const query = location2.query ? stringifyQuery2(location2.query) : \"\";\n  return location2.path + (query && \"?\") + query + (location2.hash || \"\");\n}\nfunction stripBase(pathname, base) {\n  if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase()))\n    return pathname;\n  return pathname.slice(base.length) || \"/\";\n}\nfunction isSameRouteLocation(stringifyQuery2, a, b) {\n  const aLastIndex = a.matched.length - 1;\n  const bLastIndex = b.matched.length - 1;\n  return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) && isSameRouteLocationParams(a.params, b.params) && stringifyQuery2(a.query) === stringifyQuery2(b.query) && a.hash === b.hash;\n}\nfunction isSameRouteRecord(a, b) {\n  return (a.aliasOf || a) === (b.aliasOf || b);\n}\nfunction isSameRouteLocationParams(a, b) {\n  if (Object.keys(a).length !== Object.keys(b).length)\n    return false;\n  for (const key in a) {\n    if (!isSameRouteLocationParamsValue(a[key], b[key]))\n      return false;\n  }\n  return true;\n}\nfunction isSameRouteLocationParamsValue(a, b) {\n  return isArray(a) ? isEquivalentArray(a, b) : isArray(b) ? isEquivalentArray(b, a) : a === b;\n}\nfunction isEquivalentArray(a, b) {\n  return isArray(b) ? a.length === b.length && a.every((value, i) => value === b[i]) : a.length === 1 && a[0] === b;\n}\nfunction resolveRelativePath(to, from) {\n  if (to.startsWith(\"/\"))\n    return to;\n  if (!from.startsWith(\"/\")) {\n    warn(`Cannot resolve a relative location without an absolute path. Trying to resolve \"${to}\" from \"${from}\". It should look like \"/${from}\".`);\n    return to;\n  }\n  if (!to)\n    return from;\n  const fromSegments = from.split(\"/\");\n  const toSegments = to.split(\"/\");\n  let position = fromSegments.length - 1;\n  let toPosition;\n  let segment;\n  for (toPosition = 0; toPosition < toSegments.length; toPosition++) {\n    segment = toSegments[toPosition];\n    if (segment === \".\")\n      continue;\n    if (segment === \"..\") {\n      if (position > 1)\n        position--;\n    } else\n      break;\n  }\n  return fromSegments.slice(0, position).join(\"/\") + \"/\" + toSegments.slice(toPosition - (toPosition === toSegments.length ? 1 : 0)).join(\"/\");\n}\nvar NavigationType;\n(function(NavigationType2) {\n  NavigationType2[\"pop\"] = \"pop\";\n  NavigationType2[\"push\"] = \"push\";\n})(NavigationType || (NavigationType = {}));\nvar NavigationDirection;\n(function(NavigationDirection2) {\n  NavigationDirection2[\"back\"] = \"back\";\n  NavigationDirection2[\"forward\"] = \"forward\";\n  NavigationDirection2[\"unknown\"] = \"\";\n})(NavigationDirection || (NavigationDirection = {}));\nvar START = \"\";\nfunction normalizeBase(base) {\n  if (!base) {\n    if (isBrowser) {\n      const baseEl = document.querySelector(\"base\");\n      base = baseEl && baseEl.getAttribute(\"href\") || \"/\";\n      base = base.replace(/^\\w+:\\/\\/[^\\/]+/, \"\");\n    } else {\n      base = \"/\";\n    }\n  }\n  if (base[0] !== \"/\" && base[0] !== \"#\")\n    base = \"/\" + base;\n  return removeTrailingSlash(base);\n}\nvar BEFORE_HASH_RE = /^[^#]+#/;\nfunction createHref(base, location2) {\n  return base.replace(BEFORE_HASH_RE, \"#\") + location2;\n}\nfunction getElementPosition(el, offset) {\n  const docRect = document.documentElement.getBoundingClientRect();\n  const elRect = el.getBoundingClientRect();\n  return {\n    behavior: offset.behavior,\n    left: elRect.left - docRect.left - (offset.left || 0),\n    top: elRect.top - docRect.top - (offset.top || 0)\n  };\n}\nvar computeScrollPosition = () => ({\n  left: window.pageXOffset,\n  top: window.pageYOffset\n});\nfunction scrollToPosition(position) {\n  let scrollToOptions;\n  if (\"el\" in position) {\n    const positionEl = position.el;\n    const isIdSelector = typeof positionEl === \"string\" && positionEl.startsWith(\"#\");\n    if (typeof position.el === \"string\") {\n      if (!isIdSelector || !document.getElementById(position.el.slice(1))) {\n        try {\n          const foundEl = document.querySelector(position.el);\n          if (isIdSelector && foundEl) {\n            warn(`The selector \"${position.el}\" should be passed as \"el: document.querySelector('${position.el}')\" because it starts with \"#\".`);\n            return;\n          }\n        } catch (err) {\n          warn(`The selector \"${position.el}\" is invalid. If you are using an id selector, make sure to escape it. You can find more information about escaping characters in selectors at https://mathiasbynens.be/notes/css-escapes or use CSS.escape (https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape).`);\n          return;\n        }\n      }\n    }\n    const el = typeof positionEl === \"string\" ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;\n    if (!el) {\n      warn(`Couldn't find element using selector \"${position.el}\" returned by scrollBehavior.`);\n      return;\n    }\n    scrollToOptions = getElementPosition(el, position);\n  } else {\n    scrollToOptions = position;\n  }\n  if (\"scrollBehavior\" in document.documentElement.style)\n    window.scrollTo(scrollToOptions);\n  else {\n    window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset, scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset);\n  }\n}\nfunction getScrollKey(path, delta) {\n  const position = history.state ? history.state.position - delta : -1;\n  return position + path;\n}\nvar scrollPositions = /* @__PURE__ */ new Map();\nfunction saveScrollPosition(key, scrollPosition) {\n  scrollPositions.set(key, scrollPosition);\n}\nfunction getSavedScrollPosition(key) {\n  const scroll = scrollPositions.get(key);\n  scrollPositions.delete(key);\n  return scroll;\n}\nvar createBaseLocation = () => location.protocol + \"//\" + location.host;\nfunction createCurrentLocation(base, location2) {\n  const { pathname, search, hash } = location2;\n  const hashPos = base.indexOf(\"#\");\n  if (hashPos > -1) {\n    let slicePos = hash.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;\n    let pathFromHash = hash.slice(slicePos);\n    if (pathFromHash[0] !== \"/\")\n      pathFromHash = \"/\" + pathFromHash;\n    return stripBase(pathFromHash, \"\");\n  }\n  const path = stripBase(pathname, base);\n  return path + search + hash;\n}\nfunction useHistoryListeners(base, historyState, currentLocation, replace) {\n  let listeners = [];\n  let teardowns = [];\n  let pauseState = null;\n  const popStateHandler = ({ state }) => {\n    const to = createCurrentLocation(base, location);\n    const from = currentLocation.value;\n    const fromState = historyState.value;\n    let delta = 0;\n    if (state) {\n      currentLocation.value = to;\n      historyState.value = state;\n      if (pauseState && pauseState === from) {\n        pauseState = null;\n        return;\n      }\n      delta = fromState ? state.position - fromState.position : 0;\n    } else {\n      replace(to);\n    }\n    listeners.forEach((listener) => {\n      listener(currentLocation.value, from, {\n        delta,\n        type: NavigationType.pop,\n        direction: delta ? delta > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown\n      });\n    });\n  };\n  function pauseListeners() {\n    pauseState = currentLocation.value;\n  }\n  function listen(callback) {\n    listeners.push(callback);\n    const teardown = () => {\n      const index = listeners.indexOf(callback);\n      if (index > -1)\n        listeners.splice(index, 1);\n    };\n    teardowns.push(teardown);\n    return teardown;\n  }\n  function beforeUnloadListener() {\n    const { history: history2 } = window;\n    if (!history2.state)\n      return;\n    history2.replaceState(assign({}, history2.state, { scroll: computeScrollPosition() }), \"\");\n  }\n  function destroy() {\n    for (const teardown of teardowns)\n      teardown();\n    teardowns = [];\n    window.removeEventListener(\"popstate\", popStateHandler);\n    window.removeEventListener(\"beforeunload\", beforeUnloadListener);\n  }\n  window.addEventListener(\"popstate\", popStateHandler);\n  window.addEventListener(\"beforeunload\", beforeUnloadListener);\n  return {\n    pauseListeners,\n    listen,\n    destroy\n  };\n}\nfunction buildState(back, current, forward, replaced = false, computeScroll = false) {\n  return {\n    back,\n    current,\n    forward,\n    replaced,\n    position: window.history.length,\n    scroll: computeScroll ? computeScrollPosition() : null\n  };\n}\nfunction useHistoryStateNavigation(base) {\n  const { history: history2, location: location2 } = window;\n  const currentLocation = {\n    value: createCurrentLocation(base, location2)\n  };\n  const historyState = { value: history2.state };\n  if (!historyState.value) {\n    changeLocation(currentLocation.value, {\n      back: null,\n      current: currentLocation.value,\n      forward: null,\n      position: history2.length - 1,\n      replaced: true,\n      scroll: null\n    }, true);\n  }\n  function changeLocation(to, state, replace2) {\n    const hashIndex = base.indexOf(\"#\");\n    const url = hashIndex > -1 ? (location2.host && document.querySelector(\"base\") ? base : base.slice(hashIndex)) + to : createBaseLocation() + base + to;\n    try {\n      history2[replace2 ? \"replaceState\" : \"pushState\"](state, \"\", url);\n      historyState.value = state;\n    } catch (err) {\n      if (true) {\n        warn(\"Error with push/replace State\", err);\n      } else {\n        console.error(err);\n      }\n      location2[replace2 ? \"replace\" : \"assign\"](url);\n    }\n  }\n  function replace(to, data) {\n    const state = assign({}, history2.state, buildState(\n      historyState.value.back,\n      to,\n      historyState.value.forward,\n      true\n    ), data, { position: historyState.value.position });\n    changeLocation(to, state, true);\n    currentLocation.value = to;\n  }\n  function push(to, data) {\n    const currentState = assign(\n      {},\n      historyState.value,\n      history2.state,\n      {\n        forward: to,\n        scroll: computeScrollPosition()\n      }\n    );\n    if (!history2.state) {\n      warn(`history.state seems to have been manually replaced without preserving the necessary values. Make sure to preserve existing history state if you are manually calling history.replaceState:\n\nhistory.replaceState(history.state, '', url)\n\nYou can find more information at https://next.router.vuejs.org/guide/migration/#usage-of-history-state.`);\n    }\n    changeLocation(currentState.current, currentState, true);\n    const state = assign({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data);\n    changeLocation(to, state, false);\n    currentLocation.value = to;\n  }\n  return {\n    location: currentLocation,\n    state: historyState,\n    push,\n    replace\n  };\n}\nfunction createWebHistory(base) {\n  base = normalizeBase(base);\n  const historyNavigation = useHistoryStateNavigation(base);\n  const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);\n  function go(delta, triggerListeners = true) {\n    if (!triggerListeners)\n      historyListeners.pauseListeners();\n    history.go(delta);\n  }\n  const routerHistory = assign({\n    location: \"\",\n    base,\n    go,\n    createHref: createHref.bind(null, base)\n  }, historyNavigation, historyListeners);\n  Object.defineProperty(routerHistory, \"location\", {\n    enumerable: true,\n    get: () => historyNavigation.location.value\n  });\n  Object.defineProperty(routerHistory, \"state\", {\n    enumerable: true,\n    get: () => historyNavigation.state.value\n  });\n  return routerHistory;\n}\nfunction createMemoryHistory(base = \"\") {\n  let listeners = [];\n  let queue = [START];\n  let position = 0;\n  base = normalizeBase(base);\n  function setLocation(location2) {\n    position++;\n    if (position === queue.length) {\n      queue.push(location2);\n    } else {\n      queue.splice(position);\n      queue.push(location2);\n    }\n  }\n  function triggerListeners(to, from, { direction, delta }) {\n    const info = {\n      direction,\n      delta,\n      type: NavigationType.pop\n    };\n    for (const callback of listeners) {\n      callback(to, from, info);\n    }\n  }\n  const routerHistory = {\n    location: START,\n    state: {},\n    base,\n    createHref: createHref.bind(null, base),\n    replace(to) {\n      queue.splice(position--, 1);\n      setLocation(to);\n    },\n    push(to, data) {\n      setLocation(to);\n    },\n    listen(callback) {\n      listeners.push(callback);\n      return () => {\n        const index = listeners.indexOf(callback);\n        if (index > -1)\n          listeners.splice(index, 1);\n      };\n    },\n    destroy() {\n      listeners = [];\n      queue = [START];\n      position = 0;\n    },\n    go(delta, shouldTrigger = true) {\n      const from = this.location;\n      const direction = delta < 0 ? NavigationDirection.back : NavigationDirection.forward;\n      position = Math.max(0, Math.min(position + delta, queue.length - 1));\n      if (shouldTrigger) {\n        triggerListeners(this.location, from, {\n          direction,\n          delta\n        });\n      }\n    }\n  };\n  Object.defineProperty(routerHistory, \"location\", {\n    enumerable: true,\n    get: () => queue[position]\n  });\n  return routerHistory;\n}\nfunction createWebHashHistory(base) {\n  base = location.host ? base || location.pathname + location.search : \"\";\n  if (!base.includes(\"#\"))\n    base += \"#\";\n  if (!base.endsWith(\"#/\") && !base.endsWith(\"#\")) {\n    warn(`A hash base must end with a \"#\":\n\"${base}\" should be \"${base.replace(/#.*$/, \"#\")}\".`);\n  }\n  return createWebHistory(base);\n}\nfunction isRouteLocation(route) {\n  return typeof route === \"string\" || route && typeof route === \"object\";\n}\nfunction isRouteName(name) {\n  return typeof name === \"string\" || typeof name === \"symbol\";\n}\nvar START_LOCATION_NORMALIZED = {\n  path: \"/\",\n  name: void 0,\n  params: {},\n  query: {},\n  hash: \"\",\n  fullPath: \"/\",\n  matched: [],\n  meta: {},\n  redirectedFrom: void 0\n};\nvar NavigationFailureSymbol = Symbol(true ? \"navigation failure\" : \"\");\nvar NavigationFailureType;\n(function(NavigationFailureType2) {\n  NavigationFailureType2[NavigationFailureType2[\"aborted\"] = 4] = \"aborted\";\n  NavigationFailureType2[NavigationFailureType2[\"cancelled\"] = 8] = \"cancelled\";\n  NavigationFailureType2[NavigationFailureType2[\"duplicated\"] = 16] = \"duplicated\";\n})(NavigationFailureType || (NavigationFailureType = {}));\nvar ErrorTypeMessages = {\n  [1]({ location: location2, currentLocation }) {\n    return `No match for\n ${JSON.stringify(location2)}${currentLocation ? \"\\nwhile being at\\n\" + JSON.stringify(currentLocation) : \"\"}`;\n  },\n  [2]({ from, to }) {\n    return `Redirected from \"${from.fullPath}\" to \"${stringifyRoute(to)}\" via a navigation guard.`;\n  },\n  [4]({ from, to }) {\n    return `Navigation aborted from \"${from.fullPath}\" to \"${to.fullPath}\" via a navigation guard.`;\n  },\n  [8]({ from, to }) {\n    return `Navigation cancelled from \"${from.fullPath}\" to \"${to.fullPath}\" with a new navigation.`;\n  },\n  [16]({ from, to }) {\n    return `Avoided redundant navigation to current location: \"${from.fullPath}\".`;\n  }\n};\nfunction createRouterError(type, params) {\n  if (true) {\n    return assign(new Error(ErrorTypeMessages[type](params)), {\n      type,\n      [NavigationFailureSymbol]: true\n    }, params);\n  } else {\n    return assign(new Error(), {\n      type,\n      [NavigationFailureSymbol]: true\n    }, params);\n  }\n}\nfunction isNavigationFailure(error, type) {\n  return error instanceof Error && NavigationFailureSymbol in error && (type == null || !!(error.type & type));\n}\nvar propertiesToLog = [\"params\", \"query\", \"hash\"];\nfunction stringifyRoute(to) {\n  if (typeof to === \"string\")\n    return to;\n  if (\"path\" in to)\n    return to.path;\n  const location2 = {};\n  for (const key of propertiesToLog) {\n    if (key in to)\n      location2[key] = to[key];\n  }\n  return JSON.stringify(location2, null, 2);\n}\nvar BASE_PARAM_PATTERN = \"[^/]+?\";\nvar BASE_PATH_PARSER_OPTIONS = {\n  sensitive: false,\n  strict: false,\n  start: true,\n  end: true\n};\nvar REGEX_CHARS_RE = /[.+*?^${}()[\\]/\\\\]/g;\nfunction tokensToParser(segments, extraOptions) {\n  const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);\n  const score = [];\n  let pattern = options.start ? \"^\" : \"\";\n  const keys = [];\n  for (const segment of segments) {\n    const segmentScores = segment.length ? [] : [90];\n    if (options.strict && !segment.length)\n      pattern += \"/\";\n    for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {\n      const token = segment[tokenIndex];\n      let subSegmentScore = 40 + (options.sensitive ? 0.25 : 0);\n      if (token.type === 0) {\n        if (!tokenIndex)\n          pattern += \"/\";\n        pattern += token.value.replace(REGEX_CHARS_RE, \"\\\\$&\");\n        subSegmentScore += 40;\n      } else if (token.type === 1) {\n        const { value, repeatable, optional, regexp } = token;\n        keys.push({\n          name: value,\n          repeatable,\n          optional\n        });\n        const re2 = regexp ? regexp : BASE_PARAM_PATTERN;\n        if (re2 !== BASE_PARAM_PATTERN) {\n          subSegmentScore += 10;\n          try {\n            new RegExp(`(${re2})`);\n          } catch (err) {\n            throw new Error(`Invalid custom RegExp for param \"${value}\" (${re2}): ` + err.message);\n          }\n        }\n        let subPattern = repeatable ? `((?:${re2})(?:/(?:${re2}))*)` : `(${re2})`;\n        if (!tokenIndex)\n          subPattern = optional && segment.length < 2 ? `(?:/${subPattern})` : \"/\" + subPattern;\n        if (optional)\n          subPattern += \"?\";\n        pattern += subPattern;\n        subSegmentScore += 20;\n        if (optional)\n          subSegmentScore += -8;\n        if (repeatable)\n          subSegmentScore += -20;\n        if (re2 === \".*\")\n          subSegmentScore += -50;\n      }\n      segmentScores.push(subSegmentScore);\n    }\n    score.push(segmentScores);\n  }\n  if (options.strict && options.end) {\n    const i = score.length - 1;\n    score[i][score[i].length - 1] += 0.7000000000000001;\n  }\n  if (!options.strict)\n    pattern += \"/?\";\n  if (options.end)\n    pattern += \"$\";\n  else if (options.strict)\n    pattern += \"(?:/|$)\";\n  const re = new RegExp(pattern, options.sensitive ? \"\" : \"i\");\n  function parse(path) {\n    const match = path.match(re);\n    const params = {};\n    if (!match)\n      return null;\n    for (let i = 1; i < match.length; i++) {\n      const value = match[i] || \"\";\n      const key = keys[i - 1];\n      params[key.name] = value && key.repeatable ? value.split(\"/\") : value;\n    }\n    return params;\n  }\n  function stringify(params) {\n    let path = \"\";\n    let avoidDuplicatedSlash = false;\n    for (const segment of segments) {\n      if (!avoidDuplicatedSlash || !path.endsWith(\"/\"))\n        path += \"/\";\n      avoidDuplicatedSlash = false;\n      for (const token of segment) {\n        if (token.type === 0) {\n          path += token.value;\n        } else if (token.type === 1) {\n          const { value, repeatable, optional } = token;\n          const param = value in params ? params[value] : \"\";\n          if (isArray(param) && !repeatable) {\n            throw new Error(`Provided param \"${value}\" is an array but it is not repeatable (* or + modifiers)`);\n          }\n          const text = isArray(param) ? param.join(\"/\") : param;\n          if (!text) {\n            if (optional) {\n              if (segment.length < 2) {\n                if (path.endsWith(\"/\"))\n                  path = path.slice(0, -1);\n                else\n                  avoidDuplicatedSlash = true;\n              }\n            } else\n              throw new Error(`Missing required param \"${value}\"`);\n          }\n          path += text;\n        }\n      }\n    }\n    return path || \"/\";\n  }\n  return {\n    re,\n    score,\n    keys,\n    parse,\n    stringify\n  };\n}\nfunction compareScoreArray(a, b) {\n  let i = 0;\n  while (i < a.length && i < b.length) {\n    const diff = b[i] - a[i];\n    if (diff)\n      return diff;\n    i++;\n  }\n  if (a.length < b.length) {\n    return a.length === 1 && a[0] === 40 + 40 ? -1 : 1;\n  } else if (a.length > b.length) {\n    return b.length === 1 && b[0] === 40 + 40 ? 1 : -1;\n  }\n  return 0;\n}\nfunction comparePathParserScore(a, b) {\n  let i = 0;\n  const aScore = a.score;\n  const bScore = b.score;\n  while (i < aScore.length && i < bScore.length) {\n    const comp = compareScoreArray(aScore[i], bScore[i]);\n    if (comp)\n      return comp;\n    i++;\n  }\n  if (Math.abs(bScore.length - aScore.length) === 1) {\n    if (isLastScoreNegative(aScore))\n      return 1;\n    if (isLastScoreNegative(bScore))\n      return -1;\n  }\n  return bScore.length - aScore.length;\n}\nfunction isLastScoreNegative(score) {\n  const last = score[score.length - 1];\n  return score.length > 0 && last[last.length - 1] < 0;\n}\nvar ROOT_TOKEN = {\n  type: 0,\n  value: \"\"\n};\nvar VALID_PARAM_RE = /[a-zA-Z0-9_]/;\nfunction tokenizePath(path) {\n  if (!path)\n    return [[]];\n  if (path === \"/\")\n    return [[ROOT_TOKEN]];\n  if (!path.startsWith(\"/\")) {\n    throw new Error(true ? `Route paths should start with a \"/\": \"${path}\" should be \"/${path}\".` : `Invalid path \"${path}\"`);\n  }\n  function crash(message) {\n    throw new Error(`ERR (${state})/\"${buffer}\": ${message}`);\n  }\n  let state = 0;\n  let previousState = state;\n  const tokens = [];\n  let segment;\n  function finalizeSegment() {\n    if (segment)\n      tokens.push(segment);\n    segment = [];\n  }\n  let i = 0;\n  let char;\n  let buffer = \"\";\n  let customRe = \"\";\n  function consumeBuffer() {\n    if (!buffer)\n      return;\n    if (state === 0) {\n      segment.push({\n        type: 0,\n        value: buffer\n      });\n    } else if (state === 1 || state === 2 || state === 3) {\n      if (segment.length > 1 && (char === \"*\" || char === \"+\"))\n        crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);\n      segment.push({\n        type: 1,\n        value: buffer,\n        regexp: customRe,\n        repeatable: char === \"*\" || char === \"+\",\n        optional: char === \"*\" || char === \"?\"\n      });\n    } else {\n      crash(\"Invalid state to consume buffer\");\n    }\n    buffer = \"\";\n  }\n  function addCharToBuffer() {\n    buffer += char;\n  }\n  while (i < path.length) {\n    char = path[i++];\n    if (char === \"\\\\\" && state !== 2) {\n      previousState = state;\n      state = 4;\n      continue;\n    }\n    switch (state) {\n      case 0:\n        if (char === \"/\") {\n          if (buffer) {\n            consumeBuffer();\n          }\n          finalizeSegment();\n        } else if (char === \":\") {\n          consumeBuffer();\n          state = 1;\n        } else {\n          addCharToBuffer();\n        }\n        break;\n      case 4:\n        addCharToBuffer();\n        state = previousState;\n        break;\n      case 1:\n        if (char === \"(\") {\n          state = 2;\n        } else if (VALID_PARAM_RE.test(char)) {\n          addCharToBuffer();\n        } else {\n          consumeBuffer();\n          state = 0;\n          if (char !== \"*\" && char !== \"?\" && char !== \"+\")\n            i--;\n        }\n        break;\n      case 2:\n        if (char === \")\") {\n          if (customRe[customRe.length - 1] == \"\\\\\")\n            customRe = customRe.slice(0, -1) + char;\n          else\n            state = 3;\n        } else {\n          customRe += char;\n        }\n        break;\n      case 3:\n        consumeBuffer();\n        state = 0;\n        if (char !== \"*\" && char !== \"?\" && char !== \"+\")\n          i--;\n        customRe = \"\";\n        break;\n      default:\n        crash(\"Unknown state\");\n        break;\n    }\n  }\n  if (state === 2)\n    crash(`Unfinished custom RegExp for param \"${buffer}\"`);\n  consumeBuffer();\n  finalizeSegment();\n  return tokens;\n}\nfunction createRouteRecordMatcher(record, parent, options) {\n  const parser = tokensToParser(tokenizePath(record.path), options);\n  if (true) {\n    const existingKeys = /* @__PURE__ */ new Set();\n    for (const key of parser.keys) {\n      if (existingKeys.has(key.name))\n        warn(`Found duplicated params with name \"${key.name}\" for path \"${record.path}\". Only the last one will be available on \"$route.params\".`);\n      existingKeys.add(key.name);\n    }\n  }\n  const matcher = assign(parser, {\n    record,\n    parent,\n    children: [],\n    alias: []\n  });\n  if (parent) {\n    if (!matcher.record.aliasOf === !parent.record.aliasOf)\n      parent.children.push(matcher);\n  }\n  return matcher;\n}\nfunction createRouterMatcher(routes, globalOptions) {\n  const matchers = [];\n  const matcherMap = /* @__PURE__ */ new Map();\n  globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);\n  function getRecordMatcher(name) {\n    return matcherMap.get(name);\n  }\n  function addRoute(record, parent, originalRecord) {\n    const isRootAdd = !originalRecord;\n    const mainNormalizedRecord = normalizeRouteRecord(record);\n    if (true) {\n      checkChildMissingNameWithEmptyPath(mainNormalizedRecord, parent);\n    }\n    mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;\n    const options = mergeOptions(globalOptions, record);\n    const normalizedRecords = [\n      mainNormalizedRecord\n    ];\n    if (\"alias\" in record) {\n      const aliases = typeof record.alias === \"string\" ? [record.alias] : record.alias;\n      for (const alias of aliases) {\n        normalizedRecords.push(assign({}, mainNormalizedRecord, {\n          components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,\n          path: alias,\n          aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord\n        }));\n      }\n    }\n    let matcher;\n    let originalMatcher;\n    for (const normalizedRecord of normalizedRecords) {\n      const { path } = normalizedRecord;\n      if (parent && path[0] !== \"/\") {\n        const parentPath = parent.record.path;\n        const connectingSlash = parentPath[parentPath.length - 1] === \"/\" ? \"\" : \"/\";\n        normalizedRecord.path = parent.record.path + (path && connectingSlash + path);\n      }\n      if (normalizedRecord.path === \"*\") {\n        throw new Error('Catch all routes (\"*\") must now be defined using a param with a custom regexp.\\nSee more at https://next.router.vuejs.org/guide/migration/#removed-star-or-catch-all-routes.');\n      }\n      matcher = createRouteRecordMatcher(normalizedRecord, parent, options);\n      if (parent && path[0] === \"/\")\n        checkMissingParamsInAbsolutePath(matcher, parent);\n      if (originalRecord) {\n        originalRecord.alias.push(matcher);\n        if (true) {\n          checkSameParams(originalRecord, matcher);\n        }\n      } else {\n        originalMatcher = originalMatcher || matcher;\n        if (originalMatcher !== matcher)\n          originalMatcher.alias.push(matcher);\n        if (isRootAdd && record.name && !isAliasRecord(matcher))\n          removeRoute(record.name);\n      }\n      if (mainNormalizedRecord.children) {\n        const children = mainNormalizedRecord.children;\n        for (let i = 0; i < children.length; i++) {\n          addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);\n        }\n      }\n      originalRecord = originalRecord || matcher;\n      insertMatcher(matcher);\n    }\n    return originalMatcher ? () => {\n      removeRoute(originalMatcher);\n    } : noop;\n  }\n  function removeRoute(matcherRef) {\n    if (isRouteName(matcherRef)) {\n      const matcher = matcherMap.get(matcherRef);\n      if (matcher) {\n        matcherMap.delete(matcherRef);\n        matchers.splice(matchers.indexOf(matcher), 1);\n        matcher.children.forEach(removeRoute);\n        matcher.alias.forEach(removeRoute);\n      }\n    } else {\n      const index = matchers.indexOf(matcherRef);\n      if (index > -1) {\n        matchers.splice(index, 1);\n        if (matcherRef.record.name)\n          matcherMap.delete(matcherRef.record.name);\n        matcherRef.children.forEach(removeRoute);\n        matcherRef.alias.forEach(removeRoute);\n      }\n    }\n  }\n  function getRoutes() {\n    return matchers;\n  }\n  function insertMatcher(matcher) {\n    let i = 0;\n    while (i < matchers.length && comparePathParserScore(matcher, matchers[i]) >= 0 && (matcher.record.path !== matchers[i].record.path || !isRecordChildOf(matcher, matchers[i])))\n      i++;\n    matchers.splice(i, 0, matcher);\n    if (matcher.record.name && !isAliasRecord(matcher))\n      matcherMap.set(matcher.record.name, matcher);\n  }\n  function resolve(location2, currentLocation) {\n    let matcher;\n    let params = {};\n    let path;\n    let name;\n    if (\"name\" in location2 && location2.name) {\n      matcher = matcherMap.get(location2.name);\n      if (!matcher)\n        throw createRouterError(1, {\n          location: location2\n        });\n      if (true) {\n        const invalidParams = Object.keys(location2.params || {}).filter((paramName) => !matcher.keys.find((k) => k.name === paramName));\n        if (invalidParams.length) {\n          warn(`Discarded invalid param(s) \"${invalidParams.join('\", \"')}\" when navigating. See https://github.com/vuejs/router/blob/main/packages/router/CHANGELOG.md#414-2022-08-22 for more details.`);\n        }\n      }\n      name = matcher.record.name;\n      params = assign(\n        paramsFromLocation(\n          currentLocation.params,\n          matcher.keys.filter((k) => !k.optional).map((k) => k.name)\n        ),\n        location2.params && paramsFromLocation(location2.params, matcher.keys.map((k) => k.name))\n      );\n      path = matcher.stringify(params);\n    } else if (\"path\" in location2) {\n      path = location2.path;\n      if (!path.startsWith(\"/\")) {\n        warn(`The Matcher cannot resolve relative paths but received \"${path}\". Unless you directly called \\`matcher.resolve(\"${path}\")\\`, this is probably a bug in vue-router. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/router.`);\n      }\n      matcher = matchers.find((m) => m.re.test(path));\n      if (matcher) {\n        params = matcher.parse(path);\n        name = matcher.record.name;\n      }\n    } else {\n      matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers.find((m) => m.re.test(currentLocation.path));\n      if (!matcher)\n        throw createRouterError(1, {\n          location: location2,\n          currentLocation\n        });\n      name = matcher.record.name;\n      params = assign({}, currentLocation.params, location2.params);\n      path = matcher.stringify(params);\n    }\n    const matched = [];\n    let parentMatcher = matcher;\n    while (parentMatcher) {\n      matched.unshift(parentMatcher.record);\n      parentMatcher = parentMatcher.parent;\n    }\n    return {\n      name,\n      path,\n      params,\n      matched,\n      meta: mergeMetaFields(matched)\n    };\n  }\n  routes.forEach((route) => addRoute(route));\n  return { addRoute, resolve, removeRoute, getRoutes, getRecordMatcher };\n}\nfunction paramsFromLocation(params, keys) {\n  const newParams = {};\n  for (const key of keys) {\n    if (key in params)\n      newParams[key] = params[key];\n  }\n  return newParams;\n}\nfunction normalizeRouteRecord(record) {\n  return {\n    path: record.path,\n    redirect: record.redirect,\n    name: record.name,\n    meta: record.meta || {},\n    aliasOf: void 0,\n    beforeEnter: record.beforeEnter,\n    props: normalizeRecordProps(record),\n    children: record.children || [],\n    instances: {},\n    leaveGuards: /* @__PURE__ */ new Set(),\n    updateGuards: /* @__PURE__ */ new Set(),\n    enterCallbacks: {},\n    components: \"components\" in record ? record.components || null : record.component && { default: record.component }\n  };\n}\nfunction normalizeRecordProps(record) {\n  const propsObject = {};\n  const props = record.props || false;\n  if (\"component\" in record) {\n    propsObject.default = props;\n  } else {\n    for (const name in record.components)\n      propsObject[name] = typeof props === \"boolean\" ? props : props[name];\n  }\n  return propsObject;\n}\nfunction isAliasRecord(record) {\n  while (record) {\n    if (record.record.aliasOf)\n      return true;\n    record = record.parent;\n  }\n  return false;\n}\nfunction mergeMetaFields(matched) {\n  return matched.reduce((meta, record) => assign(meta, record.meta), {});\n}\nfunction mergeOptions(defaults, partialOptions) {\n  const options = {};\n  for (const key in defaults) {\n    options[key] = key in partialOptions ? partialOptions[key] : defaults[key];\n  }\n  return options;\n}\nfunction isSameParam(a, b) {\n  return a.name === b.name && a.optional === b.optional && a.repeatable === b.repeatable;\n}\nfunction checkSameParams(a, b) {\n  for (const key of a.keys) {\n    if (!key.optional && !b.keys.find(isSameParam.bind(null, key)))\n      return warn(`Alias \"${b.record.path}\" and the original record: \"${a.record.path}\" must have the exact same param named \"${key.name}\"`);\n  }\n  for (const key of b.keys) {\n    if (!key.optional && !a.keys.find(isSameParam.bind(null, key)))\n      return warn(`Alias \"${b.record.path}\" and the original record: \"${a.record.path}\" must have the exact same param named \"${key.name}\"`);\n  }\n}\nfunction checkChildMissingNameWithEmptyPath(mainNormalizedRecord, parent) {\n  if (parent && parent.record.name && !mainNormalizedRecord.name && !mainNormalizedRecord.path) {\n    warn(`The route named \"${String(parent.record.name)}\" has a child without a name and an empty path. Using that name won't render the empty path child so you probably want to move the name to the child instead. If this is intentional, add a name to the child route to remove the warning.`);\n  }\n}\nfunction checkMissingParamsInAbsolutePath(record, parent) {\n  for (const key of parent.keys) {\n    if (!record.keys.find(isSameParam.bind(null, key)))\n      return warn(`Absolute path \"${record.record.path}\" must have the exact same param named \"${key.name}\" as its parent \"${parent.record.path}\".`);\n  }\n}\nfunction isRecordChildOf(record, parent) {\n  return parent.children.some((child) => child === record || isRecordChildOf(record, child));\n}\nvar HASH_RE = /#/g;\nvar AMPERSAND_RE = /&/g;\nvar SLASH_RE = /\\//g;\nvar EQUAL_RE = /=/g;\nvar IM_RE = /\\?/g;\nvar PLUS_RE = /\\+/g;\nvar ENC_BRACKET_OPEN_RE = /%5B/g;\nvar ENC_BRACKET_CLOSE_RE = /%5D/g;\nvar ENC_CARET_RE = /%5E/g;\nvar ENC_BACKTICK_RE = /%60/g;\nvar ENC_CURLY_OPEN_RE = /%7B/g;\nvar ENC_PIPE_RE = /%7C/g;\nvar ENC_CURLY_CLOSE_RE = /%7D/g;\nvar ENC_SPACE_RE = /%20/g;\nfunction commonEncode(text) {\n  return encodeURI(\"\" + text).replace(ENC_PIPE_RE, \"|\").replace(ENC_BRACKET_OPEN_RE, \"[\").replace(ENC_BRACKET_CLOSE_RE, \"]\");\n}\nfunction encodeHash(text) {\n  return commonEncode(text).replace(ENC_CURLY_OPEN_RE, \"{\").replace(ENC_CURLY_CLOSE_RE, \"}\").replace(ENC_CARET_RE, \"^\");\n}\nfunction encodeQueryValue(text) {\n  return commonEncode(text).replace(PLUS_RE, \"%2B\").replace(ENC_SPACE_RE, \"+\").replace(HASH_RE, \"%23\").replace(AMPERSAND_RE, \"%26\").replace(ENC_BACKTICK_RE, \"`\").replace(ENC_CURLY_OPEN_RE, \"{\").replace(ENC_CURLY_CLOSE_RE, \"}\").replace(ENC_CARET_RE, \"^\");\n}\nfunction encodeQueryKey(text) {\n  return encodeQueryValue(text).replace(EQUAL_RE, \"%3D\");\n}\nfunction encodePath(text) {\n  return commonEncode(text).replace(HASH_RE, \"%23\").replace(IM_RE, \"%3F\");\n}\nfunction encodeParam(text) {\n  return text == null ? \"\" : encodePath(text).replace(SLASH_RE, \"%2F\");\n}\nfunction decode(text) {\n  try {\n    return decodeURIComponent(\"\" + text);\n  } catch (err) {\n    warn(`Error decoding \"${text}\". Using original value`);\n  }\n  return \"\" + text;\n}\nfunction parseQuery(search) {\n  const query = {};\n  if (search === \"\" || search === \"?\")\n    return query;\n  const hasLeadingIM = search[0] === \"?\";\n  const searchParams = (hasLeadingIM ? search.slice(1) : search).split(\"&\");\n  for (let i = 0; i < searchParams.length; ++i) {\n    const searchParam = searchParams[i].replace(PLUS_RE, \" \");\n    const eqPos = searchParam.indexOf(\"=\");\n    const key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));\n    const value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));\n    if (key in query) {\n      let currentValue = query[key];\n      if (!isArray(currentValue)) {\n        currentValue = query[key] = [currentValue];\n      }\n      currentValue.push(value);\n    } else {\n      query[key] = value;\n    }\n  }\n  return query;\n}\nfunction stringifyQuery(query) {\n  let search = \"\";\n  for (let key in query) {\n    const value = query[key];\n    key = encodeQueryKey(key);\n    if (value == null) {\n      if (value !== void 0) {\n        search += (search.length ? \"&\" : \"\") + key;\n      }\n      continue;\n    }\n    const values = isArray(value) ? value.map((v) => v && encodeQueryValue(v)) : [value && encodeQueryValue(value)];\n    values.forEach((value2) => {\n      if (value2 !== void 0) {\n        search += (search.length ? \"&\" : \"\") + key;\n        if (value2 != null)\n          search += \"=\" + value2;\n      }\n    });\n  }\n  return search;\n}\nfunction normalizeQuery(query) {\n  const normalizedQuery = {};\n  for (const key in query) {\n    const value = query[key];\n    if (value !== void 0) {\n      normalizedQuery[key] = isArray(value) ? value.map((v) => v == null ? null : \"\" + v) : value == null ? value : \"\" + value;\n    }\n  }\n  return normalizedQuery;\n}\nvar matchedRouteKey = Symbol(true ? \"router view location matched\" : \"\");\nvar viewDepthKey = Symbol(true ? \"router view depth\" : \"\");\nvar routerKey = Symbol(true ? \"router\" : \"\");\nvar routeLocationKey = Symbol(true ? \"route location\" : \"\");\nvar routerViewLocationKey = Symbol(true ? \"router view location\" : \"\");\nfunction useCallbacks() {\n  let handlers = [];\n  function add(handler) {\n    handlers.push(handler);\n    return () => {\n      const i = handlers.indexOf(handler);\n      if (i > -1)\n        handlers.splice(i, 1);\n    };\n  }\n  function reset() {\n    handlers = [];\n  }\n  return {\n    add,\n    list: () => handlers,\n    reset\n  };\n}\nfunction registerGuard(record, name, guard) {\n  const removeFromList = () => {\n    record[name].delete(guard);\n  };\n  onUnmounted(removeFromList);\n  onDeactivated(removeFromList);\n  onActivated(() => {\n    record[name].add(guard);\n  });\n  record[name].add(guard);\n}\nfunction onBeforeRouteLeave(leaveGuard) {\n  if (!getCurrentInstance()) {\n    warn(\"getCurrentInstance() returned null. onBeforeRouteLeave() must be called at the top of a setup function\");\n    return;\n  }\n  const activeRecord = inject(\n    matchedRouteKey,\n    {}\n  ).value;\n  if (!activeRecord) {\n    warn(\"No active route record was found when calling `onBeforeRouteLeave()`. Make sure you call this function inside a component child of <router-view>. Maybe you called it inside of App.vue?\");\n    return;\n  }\n  registerGuard(activeRecord, \"leaveGuards\", leaveGuard);\n}\nfunction onBeforeRouteUpdate(updateGuard) {\n  if (!getCurrentInstance()) {\n    warn(\"getCurrentInstance() returned null. onBeforeRouteUpdate() must be called at the top of a setup function\");\n    return;\n  }\n  const activeRecord = inject(\n    matchedRouteKey,\n    {}\n  ).value;\n  if (!activeRecord) {\n    warn(\"No active route record was found when calling `onBeforeRouteUpdate()`. Make sure you call this function inside a component child of <router-view>. Maybe you called it inside of App.vue?\");\n    return;\n  }\n  registerGuard(activeRecord, \"updateGuards\", updateGuard);\n}\nfunction guardToPromiseFn(guard, to, from, record, name) {\n  const enterCallbackArray = record && (record.enterCallbacks[name] = record.enterCallbacks[name] || []);\n  return () => new Promise((resolve, reject) => {\n    const next = (valid) => {\n      if (valid === false) {\n        reject(createRouterError(4, {\n          from,\n          to\n        }));\n      } else if (valid instanceof Error) {\n        reject(valid);\n      } else if (isRouteLocation(valid)) {\n        reject(createRouterError(2, {\n          from: to,\n          to: valid\n        }));\n      } else {\n        if (enterCallbackArray && record.enterCallbacks[name] === enterCallbackArray && typeof valid === \"function\") {\n          enterCallbackArray.push(valid);\n        }\n        resolve();\n      }\n    };\n    const guardReturn = guard.call(record && record.instances[name], to, from, true ? canOnlyBeCalledOnce(next, to, from) : next);\n    let guardCall = Promise.resolve(guardReturn);\n    if (guard.length < 3)\n      guardCall = guardCall.then(next);\n    if (guard.length > 2) {\n      const message = `The \"next\" callback was never called inside of ${guard.name ? '\"' + guard.name + '\"' : \"\"}:\n${guard.toString()}\n. If you are returning a value instead of calling \"next\", make sure to remove the \"next\" parameter from your function.`;\n      if (typeof guardReturn === \"object\" && \"then\" in guardReturn) {\n        guardCall = guardCall.then((resolvedValue) => {\n          if (!next._called) {\n            warn(message);\n            return Promise.reject(new Error(\"Invalid navigation guard\"));\n          }\n          return resolvedValue;\n        });\n      } else if (guardReturn !== void 0) {\n        if (!next._called) {\n          warn(message);\n          reject(new Error(\"Invalid navigation guard\"));\n          return;\n        }\n      }\n    }\n    guardCall.catch((err) => reject(err));\n  });\n}\nfunction canOnlyBeCalledOnce(next, to, from) {\n  let called = 0;\n  return function() {\n    if (called++ === 1)\n      warn(`The \"next\" callback was called more than once in one navigation guard when going from \"${from.fullPath}\" to \"${to.fullPath}\". It should be called exactly one time in each navigation guard. This will fail in production.`);\n    next._called = true;\n    if (called === 1)\n      next.apply(null, arguments);\n  };\n}\nfunction extractComponentsGuards(matched, guardType, to, from) {\n  const guards = [];\n  for (const record of matched) {\n    if (!record.components && !record.children.length) {\n      warn(`Record with path \"${record.path}\" is either missing a \"component(s)\" or \"children\" property.`);\n    }\n    for (const name in record.components) {\n      let rawComponent = record.components[name];\n      if (true) {\n        if (!rawComponent || typeof rawComponent !== \"object\" && typeof rawComponent !== \"function\") {\n          warn(`Component \"${name}\" in record with path \"${record.path}\" is not a valid component. Received \"${String(rawComponent)}\".`);\n          throw new Error(\"Invalid route component\");\n        } else if (\"then\" in rawComponent) {\n          warn(`Component \"${name}\" in record with path \"${record.path}\" is a Promise instead of a function that returns a Promise. Did you write \"import('./MyPage.vue')\" instead of \"() => import('./MyPage.vue')\" ? This will break in production if not fixed.`);\n          const promise = rawComponent;\n          rawComponent = () => promise;\n        } else if (rawComponent.__asyncLoader && !rawComponent.__warnedDefineAsync) {\n          rawComponent.__warnedDefineAsync = true;\n          warn(`Component \"${name}\" in record with path \"${record.path}\" is defined using \"defineAsyncComponent()\". Write \"() => import('./MyPage.vue')\" instead of \"defineAsyncComponent(() => import('./MyPage.vue'))\".`);\n        }\n      }\n      if (guardType !== \"beforeRouteEnter\" && !record.instances[name])\n        continue;\n      if (isRouteComponent(rawComponent)) {\n        const options = rawComponent.__vccOpts || rawComponent;\n        const guard = options[guardType];\n        guard && guards.push(guardToPromiseFn(guard, to, from, record, name));\n      } else {\n        let componentPromise = rawComponent();\n        if (!(\"catch\" in componentPromise)) {\n          warn(`Component \"${name}\" in record with path \"${record.path}\" is a function that does not return a Promise. If you were passing a functional component, make sure to add a \"displayName\" to the component. This will break in production if not fixed.`);\n          componentPromise = Promise.resolve(componentPromise);\n        }\n        guards.push(() => componentPromise.then((resolved) => {\n          if (!resolved)\n            return Promise.reject(new Error(`Couldn't resolve component \"${name}\" at \"${record.path}\"`));\n          const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;\n          record.components[name] = resolvedComponent;\n          const options = resolvedComponent.__vccOpts || resolvedComponent;\n          const guard = options[guardType];\n          return guard && guardToPromiseFn(guard, to, from, record, name)();\n        }));\n      }\n    }\n  }\n  return guards;\n}\nfunction isRouteComponent(component) {\n  return typeof component === \"object\" || \"displayName\" in component || \"props\" in component || \"__vccOpts\" in component;\n}\nfunction loadRouteLocation(route) {\n  return route.matched.every((record) => record.redirect) ? Promise.reject(new Error(\"Cannot load a route that redirects.\")) : Promise.all(route.matched.map((record) => record.components && Promise.all(Object.keys(record.components).reduce((promises, name) => {\n    const rawComponent = record.components[name];\n    if (typeof rawComponent === \"function\" && !(\"displayName\" in rawComponent)) {\n      promises.push(rawComponent().then((resolved) => {\n        if (!resolved)\n          return Promise.reject(new Error(`Couldn't resolve component \"${name}\" at \"${record.path}\". Ensure you passed a function that returns a promise.`));\n        const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;\n        record.components[name] = resolvedComponent;\n        return;\n      }));\n    }\n    return promises;\n  }, [])))).then(() => route);\n}\nfunction useLink(props) {\n  const router = inject(routerKey);\n  const currentRoute = inject(routeLocationKey);\n  const route = computed(() => router.resolve(unref(props.to)));\n  const activeRecordIndex = computed(() => {\n    const { matched } = route.value;\n    const { length } = matched;\n    const routeMatched = matched[length - 1];\n    const currentMatched = currentRoute.matched;\n    if (!routeMatched || !currentMatched.length)\n      return -1;\n    const index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));\n    if (index > -1)\n      return index;\n    const parentRecordPath = getOriginalPath(matched[length - 2]);\n    return length > 1 && getOriginalPath(routeMatched) === parentRecordPath && currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index;\n  });\n  const isActive = computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));\n  const isExactActive = computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));\n  function navigate(e = {}) {\n    if (guardEvent(e)) {\n      return router[unref(props.replace) ? \"replace\" : \"push\"](\n        unref(props.to)\n      ).catch(noop);\n    }\n    return Promise.resolve();\n  }\n  if (isBrowser) {\n    const instance = getCurrentInstance();\n    if (instance) {\n      const linkContextDevtools = {\n        route: route.value,\n        isActive: isActive.value,\n        isExactActive: isExactActive.value\n      };\n      instance.__vrl_devtools = instance.__vrl_devtools || [];\n      instance.__vrl_devtools.push(linkContextDevtools);\n      watchEffect(() => {\n        linkContextDevtools.route = route.value;\n        linkContextDevtools.isActive = isActive.value;\n        linkContextDevtools.isExactActive = isExactActive.value;\n      }, { flush: \"post\" });\n    }\n  }\n  return {\n    route,\n    href: computed(() => route.value.href),\n    isActive,\n    isExactActive,\n    navigate\n  };\n}\nvar RouterLinkImpl = defineComponent({\n  name: \"RouterLink\",\n  compatConfig: { MODE: 3 },\n  props: {\n    to: {\n      type: [String, Object],\n      required: true\n    },\n    replace: Boolean,\n    activeClass: String,\n    exactActiveClass: String,\n    custom: Boolean,\n    ariaCurrentValue: {\n      type: String,\n      default: \"page\"\n    }\n  },\n  useLink,\n  setup(props, { slots }) {\n    const link = reactive(useLink(props));\n    const { options } = inject(routerKey);\n    const elClass = computed(() => ({\n      [getLinkClass(props.activeClass, options.linkActiveClass, \"router-link-active\")]: link.isActive,\n      [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, \"router-link-exact-active\")]: link.isExactActive\n    }));\n    return () => {\n      const children = slots.default && slots.default(link);\n      return props.custom ? children : h(\"a\", {\n        \"aria-current\": link.isExactActive ? props.ariaCurrentValue : null,\n        href: link.href,\n        onClick: link.navigate,\n        class: elClass.value\n      }, children);\n    };\n  }\n});\nvar RouterLink = RouterLinkImpl;\nfunction guardEvent(e) {\n  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)\n    return;\n  if (e.defaultPrevented)\n    return;\n  if (e.button !== void 0 && e.button !== 0)\n    return;\n  if (e.currentTarget && e.currentTarget.getAttribute) {\n    const target = e.currentTarget.getAttribute(\"target\");\n    if (/\\b_blank\\b/i.test(target))\n      return;\n  }\n  if (e.preventDefault)\n    e.preventDefault();\n  return true;\n}\nfunction includesParams(outer, inner) {\n  for (const key in inner) {\n    const innerValue = inner[key];\n    const outerValue = outer[key];\n    if (typeof innerValue === \"string\") {\n      if (innerValue !== outerValue)\n        return false;\n    } else {\n      if (!isArray(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i) => value !== outerValue[i]))\n        return false;\n    }\n  }\n  return true;\n}\nfunction getOriginalPath(record) {\n  return record ? record.aliasOf ? record.aliasOf.path : record.path : \"\";\n}\nvar getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;\nvar RouterViewImpl = defineComponent({\n  name: \"RouterView\",\n  inheritAttrs: false,\n  props: {\n    name: {\n      type: String,\n      default: \"default\"\n    },\n    route: Object\n  },\n  compatConfig: { MODE: 3 },\n  setup(props, { attrs, slots }) {\n    warnDeprecatedUsage();\n    const injectedRoute = inject(routerViewLocationKey);\n    const routeToDisplay = computed(() => props.route || injectedRoute.value);\n    const injectedDepth = inject(viewDepthKey, 0);\n    const depth = computed(() => {\n      let initialDepth = unref(injectedDepth);\n      const { matched } = routeToDisplay.value;\n      let matchedRoute;\n      while ((matchedRoute = matched[initialDepth]) && !matchedRoute.components) {\n        initialDepth++;\n      }\n      return initialDepth;\n    });\n    const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth.value]);\n    provide(viewDepthKey, computed(() => depth.value + 1));\n    provide(matchedRouteKey, matchedRouteRef);\n    provide(routerViewLocationKey, routeToDisplay);\n    const viewRef = ref();\n    watch(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to, name], [oldInstance, from, oldName]) => {\n      if (to) {\n        to.instances[name] = instance;\n        if (from && from !== to && instance && instance === oldInstance) {\n          if (!to.leaveGuards.size) {\n            to.leaveGuards = from.leaveGuards;\n          }\n          if (!to.updateGuards.size) {\n            to.updateGuards = from.updateGuards;\n          }\n        }\n      }\n      if (instance && to && (!from || !isSameRouteRecord(to, from) || !oldInstance)) {\n        (to.enterCallbacks[name] || []).forEach((callback) => callback(instance));\n      }\n    }, { flush: \"post\" });\n    return () => {\n      const route = routeToDisplay.value;\n      const currentName = props.name;\n      const matchedRoute = matchedRouteRef.value;\n      const ViewComponent = matchedRoute && matchedRoute.components[currentName];\n      if (!ViewComponent) {\n        return normalizeSlot(slots.default, { Component: ViewComponent, route });\n      }\n      const routePropsOption = matchedRoute.props[currentName];\n      const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === \"function\" ? routePropsOption(route) : routePropsOption : null;\n      const onVnodeUnmounted = (vnode) => {\n        if (vnode.component.isUnmounted) {\n          matchedRoute.instances[currentName] = null;\n        }\n      };\n      const component = h(ViewComponent, assign({}, routeProps, attrs, {\n        onVnodeUnmounted,\n        ref: viewRef\n      }));\n      if (isBrowser && component.ref) {\n        const info = {\n          depth: depth.value,\n          name: matchedRoute.name,\n          path: matchedRoute.path,\n          meta: matchedRoute.meta\n        };\n        const internalInstances = isArray(component.ref) ? component.ref.map((r) => r.i) : [component.ref.i];\n        internalInstances.forEach((instance) => {\n          instance.__vrv_devtools = info;\n        });\n      }\n      return normalizeSlot(slots.default, { Component: component, route }) || component;\n    };\n  }\n});\nfunction normalizeSlot(slot, data) {\n  if (!slot)\n    return null;\n  const slotContent = slot(data);\n  return slotContent.length === 1 ? slotContent[0] : slotContent;\n}\nvar RouterView = RouterViewImpl;\nfunction warnDeprecatedUsage() {\n  const instance = getCurrentInstance();\n  const parentName = instance.parent && instance.parent.type.name;\n  if (parentName && (parentName === \"KeepAlive\" || parentName.includes(\"Transition\"))) {\n    const comp = parentName === \"KeepAlive\" ? \"keep-alive\" : \"transition\";\n    warn(`<router-view> can no longer be used directly inside <transition> or <keep-alive>.\nUse slot props instead:\n\n<router-view v-slot=\"{ Component }\">\n  <${comp}>\n    <component :is=\"Component\" />\n  </${comp}>\n</router-view>`);\n  }\n}\nfunction formatRouteLocation(routeLocation, tooltip) {\n  const copy = assign({}, routeLocation, {\n    matched: routeLocation.matched.map((matched) => omit(matched, [\"instances\", \"children\", \"aliasOf\"]))\n  });\n  return {\n    _custom: {\n      type: null,\n      readOnly: true,\n      display: routeLocation.fullPath,\n      tooltip,\n      value: copy\n    }\n  };\n}\nfunction formatDisplay(display) {\n  return {\n    _custom: {\n      display\n    }\n  };\n}\nvar routerId = 0;\nfunction addDevtools(app, router, matcher) {\n  if (router.__hasDevtools)\n    return;\n  router.__hasDevtools = true;\n  const id = routerId++;\n  setupDevtoolsPlugin({\n    id: \"org.vuejs.router\" + (id ? \".\" + id : \"\"),\n    label: \"Vue Router\",\n    packageName: \"vue-router\",\n    homepage: \"https://router.vuejs.org\",\n    logo: \"https://router.vuejs.org/logo.png\",\n    componentStateTypes: [\"Routing\"],\n    app\n  }, (api) => {\n    if (typeof api.now !== \"function\") {\n      console.warn(\"[Vue Router]: You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.\");\n    }\n    api.on.inspectComponent((payload, ctx) => {\n      if (payload.instanceData) {\n        payload.instanceData.state.push({\n          type: \"Routing\",\n          key: \"$route\",\n          editable: false,\n          value: formatRouteLocation(router.currentRoute.value, \"Current Route\")\n        });\n      }\n    });\n    api.on.visitComponentTree(({ treeNode: node, componentInstance }) => {\n      if (componentInstance.__vrv_devtools) {\n        const info = componentInstance.__vrv_devtools;\n        node.tags.push({\n          label: (info.name ? `${info.name.toString()}: ` : \"\") + info.path,\n          textColor: 0,\n          tooltip: \"This component is rendered by &lt;router-view&gt;\",\n          backgroundColor: PINK_500\n        });\n      }\n      if (isArray(componentInstance.__vrl_devtools)) {\n        componentInstance.__devtoolsApi = api;\n        componentInstance.__vrl_devtools.forEach((devtoolsData) => {\n          let backgroundColor = ORANGE_400;\n          let tooltip = \"\";\n          if (devtoolsData.isExactActive) {\n            backgroundColor = LIME_500;\n            tooltip = \"This is exactly active\";\n          } else if (devtoolsData.isActive) {\n            backgroundColor = BLUE_600;\n            tooltip = \"This link is active\";\n          }\n          node.tags.push({\n            label: devtoolsData.route.path,\n            textColor: 0,\n            tooltip,\n            backgroundColor\n          });\n        });\n      }\n    });\n    watch(router.currentRoute, () => {\n      refreshRoutesView();\n      api.notifyComponentUpdate();\n      api.sendInspectorTree(routerInspectorId);\n      api.sendInspectorState(routerInspectorId);\n    });\n    const navigationsLayerId = \"router:navigations:\" + id;\n    api.addTimelineLayer({\n      id: navigationsLayerId,\n      label: `Router${id ? \" \" + id : \"\"} Navigations`,\n      color: 4237508\n    });\n    router.onError((error, to) => {\n      api.addTimelineEvent({\n        layerId: navigationsLayerId,\n        event: {\n          title: \"Error during Navigation\",\n          subtitle: to.fullPath,\n          logType: \"error\",\n          time: api.now(),\n          data: { error },\n          groupId: to.meta.__navigationId\n        }\n      });\n    });\n    let navigationId = 0;\n    router.beforeEach((to, from) => {\n      const data = {\n        guard: formatDisplay(\"beforeEach\"),\n        from: formatRouteLocation(from, \"Current Location during this navigation\"),\n        to: formatRouteLocation(to, \"Target location\")\n      };\n      Object.defineProperty(to.meta, \"__navigationId\", {\n        value: navigationId++\n      });\n      api.addTimelineEvent({\n        layerId: navigationsLayerId,\n        event: {\n          time: api.now(),\n          title: \"Start of navigation\",\n          subtitle: to.fullPath,\n          data,\n          groupId: to.meta.__navigationId\n        }\n      });\n    });\n    router.afterEach((to, from, failure) => {\n      const data = {\n        guard: formatDisplay(\"afterEach\")\n      };\n      if (failure) {\n        data.failure = {\n          _custom: {\n            type: Error,\n            readOnly: true,\n            display: failure ? failure.message : \"\",\n            tooltip: \"Navigation Failure\",\n            value: failure\n          }\n        };\n        data.status = formatDisplay(\"\\u274C\");\n      } else {\n        data.status = formatDisplay(\"\\u2705\");\n      }\n      data.from = formatRouteLocation(from, \"Current Location during this navigation\");\n      data.to = formatRouteLocation(to, \"Target location\");\n      api.addTimelineEvent({\n        layerId: navigationsLayerId,\n        event: {\n          title: \"End of navigation\",\n          subtitle: to.fullPath,\n          time: api.now(),\n          data,\n          logType: failure ? \"warning\" : \"default\",\n          groupId: to.meta.__navigationId\n        }\n      });\n    });\n    const routerInspectorId = \"router-inspector:\" + id;\n    api.addInspector({\n      id: routerInspectorId,\n      label: \"Routes\" + (id ? \" \" + id : \"\"),\n      icon: \"book\",\n      treeFilterPlaceholder: \"Search routes\"\n    });\n    function refreshRoutesView() {\n      if (!activeRoutesPayload)\n        return;\n      const payload = activeRoutesPayload;\n      let routes = matcher.getRoutes().filter((route) => !route.parent);\n      routes.forEach(resetMatchStateOnRouteRecord);\n      if (payload.filter) {\n        routes = routes.filter((route) => isRouteMatching(route, payload.filter.toLowerCase()));\n      }\n      routes.forEach((route) => markRouteRecordActive(route, router.currentRoute.value));\n      payload.rootNodes = routes.map(formatRouteRecordForInspector);\n    }\n    let activeRoutesPayload;\n    api.on.getInspectorTree((payload) => {\n      activeRoutesPayload = payload;\n      if (payload.app === app && payload.inspectorId === routerInspectorId) {\n        refreshRoutesView();\n      }\n    });\n    api.on.getInspectorState((payload) => {\n      if (payload.app === app && payload.inspectorId === routerInspectorId) {\n        const routes = matcher.getRoutes();\n        const route = routes.find((route2) => route2.record.__vd_id === payload.nodeId);\n        if (route) {\n          payload.state = {\n            options: formatRouteRecordMatcherForStateInspector(route)\n          };\n        }\n      }\n    });\n    api.sendInspectorTree(routerInspectorId);\n    api.sendInspectorState(routerInspectorId);\n  });\n}\nfunction modifierForKey(key) {\n  if (key.optional) {\n    return key.repeatable ? \"*\" : \"?\";\n  } else {\n    return key.repeatable ? \"+\" : \"\";\n  }\n}\nfunction formatRouteRecordMatcherForStateInspector(route) {\n  const { record } = route;\n  const fields = [\n    { editable: false, key: \"path\", value: record.path }\n  ];\n  if (record.name != null) {\n    fields.push({\n      editable: false,\n      key: \"name\",\n      value: record.name\n    });\n  }\n  fields.push({ editable: false, key: \"regexp\", value: route.re });\n  if (route.keys.length) {\n    fields.push({\n      editable: false,\n      key: \"keys\",\n      value: {\n        _custom: {\n          type: null,\n          readOnly: true,\n          display: route.keys.map((key) => `${key.name}${modifierForKey(key)}`).join(\" \"),\n          tooltip: \"Param keys\",\n          value: route.keys\n        }\n      }\n    });\n  }\n  if (record.redirect != null) {\n    fields.push({\n      editable: false,\n      key: \"redirect\",\n      value: record.redirect\n    });\n  }\n  if (route.alias.length) {\n    fields.push({\n      editable: false,\n      key: \"aliases\",\n      value: route.alias.map((alias) => alias.record.path)\n    });\n  }\n  if (Object.keys(route.record.meta).length) {\n    fields.push({\n      editable: false,\n      key: \"meta\",\n      value: route.record.meta\n    });\n  }\n  fields.push({\n    key: \"score\",\n    editable: false,\n    value: {\n      _custom: {\n        type: null,\n        readOnly: true,\n        display: route.score.map((score) => score.join(\", \")).join(\" | \"),\n        tooltip: \"Score used to sort routes\",\n        value: route.score\n      }\n    }\n  });\n  return fields;\n}\nvar PINK_500 = 15485081;\nvar BLUE_600 = 2450411;\nvar LIME_500 = 8702998;\nvar CYAN_400 = 2282478;\nvar ORANGE_400 = 16486972;\nvar DARK = 6710886;\nfunction formatRouteRecordForInspector(route) {\n  const tags = [];\n  const { record } = route;\n  if (record.name != null) {\n    tags.push({\n      label: String(record.name),\n      textColor: 0,\n      backgroundColor: CYAN_400\n    });\n  }\n  if (record.aliasOf) {\n    tags.push({\n      label: \"alias\",\n      textColor: 0,\n      backgroundColor: ORANGE_400\n    });\n  }\n  if (route.__vd_match) {\n    tags.push({\n      label: \"matches\",\n      textColor: 0,\n      backgroundColor: PINK_500\n    });\n  }\n  if (route.__vd_exactActive) {\n    tags.push({\n      label: \"exact\",\n      textColor: 0,\n      backgroundColor: LIME_500\n    });\n  }\n  if (route.__vd_active) {\n    tags.push({\n      label: \"active\",\n      textColor: 0,\n      backgroundColor: BLUE_600\n    });\n  }\n  if (record.redirect) {\n    tags.push({\n      label: typeof record.redirect === \"string\" ? `redirect: ${record.redirect}` : \"redirects\",\n      textColor: 16777215,\n      backgroundColor: DARK\n    });\n  }\n  let id = record.__vd_id;\n  if (id == null) {\n    id = String(routeRecordId++);\n    record.__vd_id = id;\n  }\n  return {\n    id,\n    label: record.path,\n    tags,\n    children: route.children.map(formatRouteRecordForInspector)\n  };\n}\nvar routeRecordId = 0;\nvar EXTRACT_REGEXP_RE = /^\\/(.*)\\/([a-z]*)$/;\nfunction markRouteRecordActive(route, currentRoute) {\n  const isExactActive = currentRoute.matched.length && isSameRouteRecord(currentRoute.matched[currentRoute.matched.length - 1], route.record);\n  route.__vd_exactActive = route.__vd_active = isExactActive;\n  if (!isExactActive) {\n    route.__vd_active = currentRoute.matched.some((match) => isSameRouteRecord(match, route.record));\n  }\n  route.children.forEach((childRoute) => markRouteRecordActive(childRoute, currentRoute));\n}\nfunction resetMatchStateOnRouteRecord(route) {\n  route.__vd_match = false;\n  route.children.forEach(resetMatchStateOnRouteRecord);\n}\nfunction isRouteMatching(route, filter) {\n  const found = String(route.re).match(EXTRACT_REGEXP_RE);\n  route.__vd_match = false;\n  if (!found || found.length < 3) {\n    return false;\n  }\n  const nonEndingRE = new RegExp(found[1].replace(/\\$$/, \"\"), found[2]);\n  if (nonEndingRE.test(filter)) {\n    route.children.forEach((child) => isRouteMatching(child, filter));\n    if (route.record.path !== \"/\" || filter === \"/\") {\n      route.__vd_match = route.re.test(filter);\n      return true;\n    }\n    return false;\n  }\n  const path = route.record.path.toLowerCase();\n  const decodedPath = decode(path);\n  if (!filter.startsWith(\"/\") && (decodedPath.includes(filter) || path.includes(filter)))\n    return true;\n  if (decodedPath.startsWith(filter) || path.startsWith(filter))\n    return true;\n  if (route.record.name && String(route.record.name).includes(filter))\n    return true;\n  return route.children.some((child) => isRouteMatching(child, filter));\n}\nfunction omit(obj, keys) {\n  const ret = {};\n  for (const key in obj) {\n    if (!keys.includes(key)) {\n      ret[key] = obj[key];\n    }\n  }\n  return ret;\n}\nfunction createRouter(options) {\n  const matcher = createRouterMatcher(options.routes, options);\n  const parseQuery$1 = options.parseQuery || parseQuery;\n  const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;\n  const routerHistory = options.history;\n  if (!routerHistory)\n    throw new Error('Provide the \"history\" option when calling \"createRouter()\": https://next.router.vuejs.org/api/#history.');\n  const beforeGuards = useCallbacks();\n  const beforeResolveGuards = useCallbacks();\n  const afterGuards = useCallbacks();\n  const currentRoute = shallowRef(START_LOCATION_NORMALIZED);\n  let pendingLocation = START_LOCATION_NORMALIZED;\n  if (isBrowser && options.scrollBehavior && \"scrollRestoration\" in history) {\n    history.scrollRestoration = \"manual\";\n  }\n  const normalizeParams = applyToParams.bind(null, (paramValue) => \"\" + paramValue);\n  const encodeParams = applyToParams.bind(null, encodeParam);\n  const decodeParams = applyToParams.bind(null, decode);\n  function addRoute(parentOrRoute, route) {\n    let parent;\n    let record;\n    if (isRouteName(parentOrRoute)) {\n      parent = matcher.getRecordMatcher(parentOrRoute);\n      record = route;\n    } else {\n      record = parentOrRoute;\n    }\n    return matcher.addRoute(record, parent);\n  }\n  function removeRoute(name) {\n    const recordMatcher = matcher.getRecordMatcher(name);\n    if (recordMatcher) {\n      matcher.removeRoute(recordMatcher);\n    } else if (true) {\n      warn(`Cannot remove non-existent route \"${String(name)}\"`);\n    }\n  }\n  function getRoutes() {\n    return matcher.getRoutes().map((routeMatcher) => routeMatcher.record);\n  }\n  function hasRoute(name) {\n    return !!matcher.getRecordMatcher(name);\n  }\n  function resolve(rawLocation, currentLocation) {\n    currentLocation = assign({}, currentLocation || currentRoute.value);\n    if (typeof rawLocation === \"string\") {\n      const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);\n      const matchedRoute2 = matcher.resolve({ path: locationNormalized.path }, currentLocation);\n      const href2 = routerHistory.createHref(locationNormalized.fullPath);\n      if (true) {\n        if (href2.startsWith(\"//\"))\n          warn(`Location \"${rawLocation}\" resolved to \"${href2}\". A resolved location cannot start with multiple slashes.`);\n        else if (!matchedRoute2.matched.length) {\n          warn(`No match found for location with path \"${rawLocation}\"`);\n        }\n      }\n      return assign(locationNormalized, matchedRoute2, {\n        params: decodeParams(matchedRoute2.params),\n        hash: decode(locationNormalized.hash),\n        redirectedFrom: void 0,\n        href: href2\n      });\n    }\n    let matcherLocation;\n    if (\"path\" in rawLocation) {\n      if (\"params\" in rawLocation && !(\"name\" in rawLocation) && Object.keys(rawLocation.params).length) {\n        warn(`Path \"${rawLocation.path}\" was passed with params but they will be ignored. Use a named route alongside params instead.`);\n      }\n      matcherLocation = assign({}, rawLocation, {\n        path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path\n      });\n    } else {\n      const targetParams = assign({}, rawLocation.params);\n      for (const key in targetParams) {\n        if (targetParams[key] == null) {\n          delete targetParams[key];\n        }\n      }\n      matcherLocation = assign({}, rawLocation, {\n        params: encodeParams(rawLocation.params)\n      });\n      currentLocation.params = encodeParams(currentLocation.params);\n    }\n    const matchedRoute = matcher.resolve(matcherLocation, currentLocation);\n    const hash = rawLocation.hash || \"\";\n    if (hash && !hash.startsWith(\"#\")) {\n      warn(`A \\`hash\\` should always start with the character \"#\". Replace \"${hash}\" with \"#${hash}\".`);\n    }\n    matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));\n    const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {\n      hash: encodeHash(hash),\n      path: matchedRoute.path\n    }));\n    const href = routerHistory.createHref(fullPath);\n    if (true) {\n      if (href.startsWith(\"//\")) {\n        warn(`Location \"${rawLocation}\" resolved to \"${href}\". A resolved location cannot start with multiple slashes.`);\n      } else if (!matchedRoute.matched.length) {\n        warn(`No match found for location with path \"${\"path\" in rawLocation ? rawLocation.path : rawLocation}\"`);\n      }\n    }\n    return assign({\n      fullPath,\n      hash,\n      query: stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}\n    }, matchedRoute, {\n      redirectedFrom: void 0,\n      href\n    });\n  }\n  function locationAsObject(to) {\n    return typeof to === \"string\" ? parseURL(parseQuery$1, to, currentRoute.value.path) : assign({}, to);\n  }\n  function checkCanceledNavigation(to, from) {\n    if (pendingLocation !== to) {\n      return createRouterError(8, {\n        from,\n        to\n      });\n    }\n  }\n  function push(to) {\n    return pushWithRedirect(to);\n  }\n  function replace(to) {\n    return push(assign(locationAsObject(to), { replace: true }));\n  }\n  function handleRedirectRecord(to) {\n    const lastMatched = to.matched[to.matched.length - 1];\n    if (lastMatched && lastMatched.redirect) {\n      const { redirect } = lastMatched;\n      let newTargetLocation = typeof redirect === \"function\" ? redirect(to) : redirect;\n      if (typeof newTargetLocation === \"string\") {\n        newTargetLocation = newTargetLocation.includes(\"?\") || newTargetLocation.includes(\"#\") ? newTargetLocation = locationAsObject(newTargetLocation) : { path: newTargetLocation };\n        newTargetLocation.params = {};\n      }\n      if (!(\"path\" in newTargetLocation) && !(\"name\" in newTargetLocation)) {\n        warn(`Invalid redirect found:\n${JSON.stringify(newTargetLocation, null, 2)}\n when navigating to \"${to.fullPath}\". A redirect must contain a name or path. This will break in production.`);\n        throw new Error(\"Invalid redirect\");\n      }\n      return assign({\n        query: to.query,\n        hash: to.hash,\n        params: \"path\" in newTargetLocation ? {} : to.params\n      }, newTargetLocation);\n    }\n  }\n  function pushWithRedirect(to, redirectedFrom) {\n    const targetLocation = pendingLocation = resolve(to);\n    const from = currentRoute.value;\n    const data = to.state;\n    const force = to.force;\n    const replace2 = to.replace === true;\n    const shouldRedirect = handleRedirectRecord(targetLocation);\n    if (shouldRedirect)\n      return pushWithRedirect(\n        assign(locationAsObject(shouldRedirect), {\n          state: typeof shouldRedirect === \"object\" ? assign({}, data, shouldRedirect.state) : data,\n          force,\n          replace: replace2\n        }),\n        redirectedFrom || targetLocation\n      );\n    const toLocation = targetLocation;\n    toLocation.redirectedFrom = redirectedFrom;\n    let failure;\n    if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {\n      failure = createRouterError(16, { to: toLocation, from });\n      handleScroll(\n        from,\n        from,\n        true,\n        false\n      );\n    }\n    return (failure ? Promise.resolve(failure) : navigate(toLocation, from)).catch((error) => isNavigationFailure(error) ? isNavigationFailure(error, 2) ? error : markAsReady(error) : triggerError(error, toLocation, from)).then((failure2) => {\n      if (failure2) {\n        if (isNavigationFailure(failure2, 2)) {\n          if (isSameRouteLocation(stringifyQuery$1, resolve(failure2.to), toLocation) && redirectedFrom && (redirectedFrom._count = redirectedFrom._count ? redirectedFrom._count + 1 : 1) > 10) {\n            warn(`Detected an infinite redirection in a navigation guard when going from \"${from.fullPath}\" to \"${toLocation.fullPath}\". Aborting to avoid a Stack Overflow. This will break in production if not fixed.`);\n            return Promise.reject(new Error(\"Infinite redirect in navigation guard\"));\n          }\n          return pushWithRedirect(\n            assign({\n              replace: replace2\n            }, locationAsObject(failure2.to), {\n              state: typeof failure2.to === \"object\" ? assign({}, data, failure2.to.state) : data,\n              force\n            }),\n            redirectedFrom || toLocation\n          );\n        }\n      } else {\n        failure2 = finalizeNavigation(toLocation, from, true, replace2, data);\n      }\n      triggerAfterEach(toLocation, from, failure2);\n      return failure2;\n    });\n  }\n  function checkCanceledNavigationAndReject(to, from) {\n    const error = checkCanceledNavigation(to, from);\n    return error ? Promise.reject(error) : Promise.resolve();\n  }\n  function navigate(to, from) {\n    let guards;\n    const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);\n    guards = extractComponentsGuards(leavingRecords.reverse(), \"beforeRouteLeave\", to, from);\n    for (const record of leavingRecords) {\n      record.leaveGuards.forEach((guard) => {\n        guards.push(guardToPromiseFn(guard, to, from));\n      });\n    }\n    const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);\n    guards.push(canceledNavigationCheck);\n    return runGuardQueue(guards).then(() => {\n      guards = [];\n      for (const guard of beforeGuards.list()) {\n        guards.push(guardToPromiseFn(guard, to, from));\n      }\n      guards.push(canceledNavigationCheck);\n      return runGuardQueue(guards);\n    }).then(() => {\n      guards = extractComponentsGuards(updatingRecords, \"beforeRouteUpdate\", to, from);\n      for (const record of updatingRecords) {\n        record.updateGuards.forEach((guard) => {\n          guards.push(guardToPromiseFn(guard, to, from));\n        });\n      }\n      guards.push(canceledNavigationCheck);\n      return runGuardQueue(guards);\n    }).then(() => {\n      guards = [];\n      for (const record of to.matched) {\n        if (record.beforeEnter && !from.matched.includes(record)) {\n          if (isArray(record.beforeEnter)) {\n            for (const beforeEnter of record.beforeEnter)\n              guards.push(guardToPromiseFn(beforeEnter, to, from));\n          } else {\n            guards.push(guardToPromiseFn(record.beforeEnter, to, from));\n          }\n        }\n      }\n      guards.push(canceledNavigationCheck);\n      return runGuardQueue(guards);\n    }).then(() => {\n      to.matched.forEach((record) => record.enterCallbacks = {});\n      guards = extractComponentsGuards(enteringRecords, \"beforeRouteEnter\", to, from);\n      guards.push(canceledNavigationCheck);\n      return runGuardQueue(guards);\n    }).then(() => {\n      guards = [];\n      for (const guard of beforeResolveGuards.list()) {\n        guards.push(guardToPromiseFn(guard, to, from));\n      }\n      guards.push(canceledNavigationCheck);\n      return runGuardQueue(guards);\n    }).catch((err) => isNavigationFailure(err, 8) ? err : Promise.reject(err));\n  }\n  function triggerAfterEach(to, from, failure) {\n    for (const guard of afterGuards.list())\n      guard(to, from, failure);\n  }\n  function finalizeNavigation(toLocation, from, isPush, replace2, data) {\n    const error = checkCanceledNavigation(toLocation, from);\n    if (error)\n      return error;\n    const isFirstNavigation = from === START_LOCATION_NORMALIZED;\n    const state = !isBrowser ? {} : history.state;\n    if (isPush) {\n      if (replace2 || isFirstNavigation)\n        routerHistory.replace(toLocation.fullPath, assign({\n          scroll: isFirstNavigation && state && state.scroll\n        }, data));\n      else\n        routerHistory.push(toLocation.fullPath, data);\n    }\n    currentRoute.value = toLocation;\n    handleScroll(toLocation, from, isPush, isFirstNavigation);\n    markAsReady();\n  }\n  let removeHistoryListener;\n  function setupListeners() {\n    if (removeHistoryListener)\n      return;\n    removeHistoryListener = routerHistory.listen((to, _from, info) => {\n      if (!router.listening)\n        return;\n      const toLocation = resolve(to);\n      const shouldRedirect = handleRedirectRecord(toLocation);\n      if (shouldRedirect) {\n        pushWithRedirect(assign(shouldRedirect, { replace: true }), toLocation).catch(noop);\n        return;\n      }\n      pendingLocation = toLocation;\n      const from = currentRoute.value;\n      if (isBrowser) {\n        saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());\n      }\n      navigate(toLocation, from).catch((error) => {\n        if (isNavigationFailure(error, 4 | 8)) {\n          return error;\n        }\n        if (isNavigationFailure(error, 2)) {\n          pushWithRedirect(\n            error.to,\n            toLocation\n          ).then((failure) => {\n            if (isNavigationFailure(failure, 4 | 16) && !info.delta && info.type === NavigationType.pop) {\n              routerHistory.go(-1, false);\n            }\n          }).catch(noop);\n          return Promise.reject();\n        }\n        if (info.delta) {\n          routerHistory.go(-info.delta, false);\n        }\n        return triggerError(error, toLocation, from);\n      }).then((failure) => {\n        failure = failure || finalizeNavigation(\n          toLocation,\n          from,\n          false\n        );\n        if (failure) {\n          if (info.delta && !isNavigationFailure(failure, 8)) {\n            routerHistory.go(-info.delta, false);\n          } else if (info.type === NavigationType.pop && isNavigationFailure(failure, 4 | 16)) {\n            routerHistory.go(-1, false);\n          }\n        }\n        triggerAfterEach(toLocation, from, failure);\n      }).catch(noop);\n    });\n  }\n  let readyHandlers = useCallbacks();\n  let errorHandlers = useCallbacks();\n  let ready;\n  function triggerError(error, to, from) {\n    markAsReady(error);\n    const list = errorHandlers.list();\n    if (list.length) {\n      list.forEach((handler) => handler(error, to, from));\n    } else {\n      if (true) {\n        warn(\"uncaught error during route navigation:\");\n      }\n      console.error(error);\n    }\n    return Promise.reject(error);\n  }\n  function isReady() {\n    if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)\n      return Promise.resolve();\n    return new Promise((resolve2, reject) => {\n      readyHandlers.add([resolve2, reject]);\n    });\n  }\n  function markAsReady(err) {\n    if (!ready) {\n      ready = !err;\n      setupListeners();\n      readyHandlers.list().forEach(([resolve2, reject]) => err ? reject(err) : resolve2());\n      readyHandlers.reset();\n    }\n    return err;\n  }\n  function handleScroll(to, from, isPush, isFirstNavigation) {\n    const { scrollBehavior } = options;\n    if (!isBrowser || !scrollBehavior)\n      return Promise.resolve();\n    const scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;\n    return nextTick().then(() => scrollBehavior(to, from, scrollPosition)).then((position) => position && scrollToPosition(position)).catch((err) => triggerError(err, to, from));\n  }\n  const go = (delta) => routerHistory.go(delta);\n  let started;\n  const installedApps = /* @__PURE__ */ new Set();\n  const router = {\n    currentRoute,\n    listening: true,\n    addRoute,\n    removeRoute,\n    hasRoute,\n    getRoutes,\n    resolve,\n    options,\n    push,\n    replace,\n    go,\n    back: () => go(-1),\n    forward: () => go(1),\n    beforeEach: beforeGuards.add,\n    beforeResolve: beforeResolveGuards.add,\n    afterEach: afterGuards.add,\n    onError: errorHandlers.add,\n    isReady,\n    install(app) {\n      const router2 = this;\n      app.component(\"RouterLink\", RouterLink);\n      app.component(\"RouterView\", RouterView);\n      app.config.globalProperties.$router = router2;\n      Object.defineProperty(app.config.globalProperties, \"$route\", {\n        enumerable: true,\n        get: () => unref(currentRoute)\n      });\n      if (isBrowser && !started && currentRoute.value === START_LOCATION_NORMALIZED) {\n        started = true;\n        push(routerHistory.location).catch((err) => {\n          if (true)\n            warn(\"Unexpected error when starting the router:\", err);\n        });\n      }\n      const reactiveRoute = {};\n      for (const key in START_LOCATION_NORMALIZED) {\n        reactiveRoute[key] = computed(() => currentRoute.value[key]);\n      }\n      app.provide(routerKey, router2);\n      app.provide(routeLocationKey, reactive(reactiveRoute));\n      app.provide(routerViewLocationKey, currentRoute);\n      const unmountApp = app.unmount;\n      installedApps.add(app);\n      app.unmount = function() {\n        installedApps.delete(app);\n        if (installedApps.size < 1) {\n          pendingLocation = START_LOCATION_NORMALIZED;\n          removeHistoryListener && removeHistoryListener();\n          removeHistoryListener = null;\n          currentRoute.value = START_LOCATION_NORMALIZED;\n          started = false;\n          ready = false;\n        }\n        unmountApp();\n      };\n      if (isBrowser) {\n        addDevtools(app, router2, matcher);\n      }\n    }\n  };\n  return router;\n}\nfunction runGuardQueue(guards) {\n  return guards.reduce((promise, guard) => promise.then(() => guard()), Promise.resolve());\n}\nfunction extractChangingRecords(to, from) {\n  const leavingRecords = [];\n  const updatingRecords = [];\n  const enteringRecords = [];\n  const len = Math.max(from.matched.length, to.matched.length);\n  for (let i = 0; i < len; i++) {\n    const recordFrom = from.matched[i];\n    if (recordFrom) {\n      if (to.matched.find((record) => isSameRouteRecord(record, recordFrom)))\n        updatingRecords.push(recordFrom);\n      else\n        leavingRecords.push(recordFrom);\n    }\n    const recordTo = to.matched[i];\n    if (recordTo) {\n      if (!from.matched.find((record) => isSameRouteRecord(record, recordTo))) {\n        enteringRecords.push(recordTo);\n      }\n    }\n  }\n  return [leavingRecords, updatingRecords, enteringRecords];\n}\nfunction useRouter() {\n  return inject(routerKey);\n}\nfunction useRoute() {\n  return inject(routeLocationKey);\n}\n\nexport {\n  createWebHistory,\n  createMemoryHistory,\n  createWebHashHistory,\n  START_LOCATION_NORMALIZED,\n  NavigationFailureType,\n  isNavigationFailure,\n  createRouterMatcher,\n  parseQuery,\n  stringifyQuery,\n  matchedRouteKey,\n  viewDepthKey,\n  routerKey,\n  routeLocationKey,\n  routerViewLocationKey,\n  onBeforeRouteLeave,\n  onBeforeRouteUpdate,\n  loadRouteLocation,\n  useLink,\n  RouterLink,\n  RouterView,\n  createRouter,\n  useRouter,\n  useRoute\n};\n/*!\n  * vue-router v4.1.5\n  * (c) 2022 Eduardo San Martin Morote\n  * @license MIT\n  */\n//# sourceMappingURL=chunk-L5H4ESUF.js.map\n","start":1663126497547,"end":1663126497549,"order":"normal"}]}
